%&pdflatex
\documentclass{scrreprt}

\usepackage[pdftex]{graphicx}

\usepackage{colortbl}	
\usepackage{xcolor}
\usepackage{soul}

\renewcommand{\familydefault}{\sfdefault}
\definecolor{uhhred}{cmyk}{0,100,100,0}
\input{stylesvs}
\addbibresource{main.bib}

\begin{document}

\title{Privatsphärewahrendes Anreiz- und Betrugserkennungssystem im\\ Datentreuhandmodell}
\author{Knut Hoffmeister}

\newgeometry{centering,left=2cm,right=2cm,top=2cm,bottom=2cm}
\begin{titlepage}
\includegraphics[width=6.8cm]{up-uhh-logo-u-2010-u-farbe-u-rgb.pdf}
\begin{center}
    \vfill
    \Large Bachelorarbeit
    \vfill
    \makeatletter
    {\Large\textsf{\textbf{\@title}}}
    \makeatother
    \vfill
    vorgelegt von
    \par\bigskip
    \makeatletter
    {\@author}
    \makeatother
    \par
    Matrikelnummer 7509085 \par
    Studiengang Software System Entwicklung
    \vfill
    MIN-Fakultät \par
    Fachbereich Informatik
    \vfill
    \makeatletter
    eingereicht am {\@date}
    \makeatother
    \vfill
    Erstgutachter: Mathias Fischer\\
    Zweigutachter: Kevin Röbert
\end{center}
\ifoptionfinal{}{
    \begin{tikzpicture}[remember picture, overlay]
        \node[draw, red, font=\ttfamily\bfseries\Large, xshift=30mm, yshift=238mm, rotate=340, text centered, text width=6cm, very thick, rounded corners=4mm] at (current page.south) {Entwurf vom \today};
    \end{tikzpicture}
}
\end{titlepage}

\restoregeometry

\tableofcontents


\chapter*{Abstract}


%==================================================================================================


\chapter{Einleitung}
%``Die Bedeutung der Datenökonomie für die Entwicklung der Wirtschaftsleistung in Deutschland und Europa ist unbestritten`` \cite{falck2020rohstoff}\\
\label{chap:intro}
In der heutigen Zeit wird der fachgerechte Umgang mit Daten jeglicher Form zunehmend wichtiger. Viele der großen Player wie Facebook oder Google machen ihr Hauptgeschäft mit dem Verwenden von Nutzerdaten zu gewerblichen Zwecken, wie beispielsweise Targeted Ads \cite{facebookad,googlead}. Und obwohl das Misstrauen eines Nutzers, gegenüber solch einem großen Unternehmen  berechtigt ist, benötigen diese die gesammelten Daten auch dazu, neue Technologien zu entwickeln. Jedoch hat der Nutzer, der diese Daten generiert, meist keinen Einblick darin, wer seine Daten verwendet und wofür diese zum Einsatz kommen. Ein potenzieller Lösungsansatz für dieses Problem ist die Verwendung von Datentreuhändersystemen. In einem Datentreuhändersystem kann ein datengenerierender Endnutzer seine Daten verschlüsselt bei einem Treuhänder lagern. Zum anderen ist der Treuhänder ein Mediator zwischen dem Endnutzer und einem Unternehmen, das an den Daten interessiert ist. Möchte nun ein Unternehmen die Daten für ihre Zwecke verwenden, so kann dieses bei dem Treuhänder Daten anfordern. Daraufhin kontaktiert der Treuhänder den Nutzer von dem die Daten stammen und fragt diesen nach seiner Zustimmung. So kann der Nutzer genau einsehen, wer seine Daten verwenden möchte und kann unerwünschte Benutzung unterbinden. Das Ziel liegt hierbei vor allem darin den Nutzer und seine Privatsphäre so gut wie möglich zu schützen.

In dieser Bachelorarbeit sollen - um die Motivation zur Benutzung eines Datentreuhänder zu erhöhen - zwei Forschungsfragen beantwortet werden: Wie kann ein privatsphäreschützender Anreiz zur Benutzung eines Datentreuhändermodells geschaffen werden? Und: Wie kann dieser Anreiz gegen Missbrauch geschützt werden? Aktuell ist der einzige Anreiz zur Benutzung eines Datentreuhändermodells für den Nutzer der Schutz der Privatsphäre durch die Kommunikation über den Treuhänder. Um einen weiteren Anreiz zu bieten, soll hier ein Ansatz vorgestellt werden, der den Datengebenden für seine zur Verfügung gestellten Daten angemessen entlohnt. Dies geschieht durch eine Transaktion von dem Datennutzenden an den Datengebenden, die trotz des Austausches von Zahlungsinformationen, die Privatsphäre des Datengebenden und dessen Identität so weit wie möglich schützt. Hierfür könnte beispielsweise eine leicht erweiterte Version des GNU Taler Zahlungssystem verwendet werden (siehe Abschnitt \ref{subsec:gnu}), um den Zahlungsverkehr zwischen den Parteien zu ermöglichen. Um dieses System vor Missbrauch zu schützen, wird ein Reputationssystem eingesetzt um zu verhindern, dass ein Datengebender wertlose Daten oder qualitativ niedrigwertige Daten, in großer Masse bereitstellen kann, um so das System auszunutzen. Es soll einerseits - gleich dem Bezahlvorgang - die Identität des Datengebenden schützen. Gleichzeitig soll es den Datennutzenden - der die Bewertung ausstellt - davon abhalten, das System durch mehrfaches Bewerten auszunutzen. Auch Betrugsversuche des Datengebenden sind nicht zu vernachlässigen, wie beispielsweise die Neuanmeldung eines Nutzers mit schlechter Reputation, um diesen Wert zurückzusetzen.

Dafür wird in dieser Arbeit der aktuelle Stand der Forschung in dem vorliegenden Kontext evaluiert und geprüft, was bereits anwendbar und wo noch Lücken zur gewünschten Verwendung bestehen. Mit den gesammelten Forschungsergebnissen wird daraufhin ein Konzept präsentiert, um das gerade genannte Ziel in das Treuhändermodell zu integrieren. Dieses Konzept wird desweiteren in ein bestehendes Treuhändersystem eingebaut, um konkrete Vergleichsgrundlagen zu erhalten. Bei dem hierfür vorgesehenen System handelt es sich um das Tresor-Projekt der Universität Hamburg \cite{TRESOR}.


%==================================================================================================


\chapter{Grundlagen}
Die zunehmende Digitalisierung unseres Alltags ist unbestreitbar \cite{dt-digitalisierung-stat}. Viele der täglichen Aktivitäten basieren stark darauf. Sei es den schnellsten Weg zur Arbeit mit Google Maps zu finden, das kontaktlose Bezahlen an der Kasse mit GooglePay oder Applepay, die Benutzung von Social Media zur Unterhaltung oder der Onlinehandel über Anbieter wie Amazon. Sie alle liefern Komfort, der durch die zunehmende Verwendung von Computern ermöglicht wird, die im Hintergrund Unmengen an Daten für ihre Berechnungen verwenden. Diese Daten stammen meist von den Benutzern selbst. beispielsweise die Standortdaten für die Berechnung potenzieller Staus im Straßennetz \cite{dt-googlemaps-staus} oder die Unterhaltungsinteressen basierend auf Watchtime von bestimmten Social Media Inhalten. \\
Aufgrund des ständig wachsenden Marktes für neue Digitaltechnologien ist auch die Nachfrage nach Daten im laufe der letzten Jahre in die Höhe gestiegen. Im letzten Jahrzehnt haben die Daten, das Öl als wertvollste Ressource abgelöst. Während im Jahr 2008 die vier weltweit wertvollsten Unternehmen Ölkonzerne waren, waren es in 2018 bereits die sieben wertvollsten Unternehmen Internet- und Technologiefirmen \cite{dt-falck2020rohstoff}. 

\section{Reguläre Datenkommunikation}
In Anbetracht des hohen Wertes von Daten sind viele Unternehmen verständlicherweise mit dem Austausch der Daten zurückhaltend. Schließlich beutet eine eigene Datensammlung ein potenzielles Verkaufsgut. Laut einer Studie von Fedkenhauer et al. geben zwar viele der befragten Unternehmen an, Aktivitäten im Bereich des Datenaustausches zu betreiben, allerdings umfasst das in 83\% der Fälle den Austausch von Daten mit Kundinnen und Kunden. 53\% der Unternehmen teilen ihre Daten mit Lieferantinnen und Lieferanten. Ein noch kleinerer Anteil von 21\% teilt seine Daten mit Unternehmen aus den gleichen oder anderen Branchen und nur 15\% teilen sie mit Wettbewerbern \cite{dt-fedkenhauer2017datenaustausch}. \\\\
Aus der kapitalgetriebenen Sicht eines Unternehmens besitzt das Teilen der eigenen Daten keinen direkten Nutzen. Da ein Unternehmen seine eigene Gewinnmaximierung anstrebt, ist das Teilen von Daten eher ein Nachteil, da fremde Unternehmen mit den selbst gesammelten Daten ihre Produkte qualitativ erweitern können. Dadurch werden entweder andere Wettbewerber oder branchenfremde Unternehmen in ihrem Marktwert gefördert, was zu der Verrinnerungen des eigenen Marktanteils führt. \\
Diese protektive Herangehensweise kann allerdings auch der Gewinnmaximierung im Weg stehen. Im Fall vom direktem Tausch an Daten können beide Parteien einen Profit aus der Interaktion erwirtschaften. Die Bundesregierung selbst schreibt in \cite{dt-bundesregierung2021datenstrategie}, dass kaum Datenkooperationen zwischen staatlichen und wirtschaftlichen Akteurinnen bestehen, obwohl die staatlich gesammelten Daten eine Grundlage für wirtschaftliche Innovation sein könnten. Im Gegenzug könnten die Daten von Unternehmen dem Staat bei der Sicherstellung seines Versorgungsauftrages, der Daseinsvorsorge und der Wahrung öffentlicher Schutzgüter helfen. Dies ist eine optimale Situation für die Verwendung eines Datentreuhänders.
\section{Datentreuhänder}
\label{sec:dt}
Ein Datentreuhänder ist ein neutraler vertrauenswürdiger Vermittler von Daten eines Datengebenden zu einem Datennutzenden. Er hat selbst kein kommerzielles Interesse an der Verwertung der Daten und agiert vergleichbar zu einem Notar im Sinne des Datengebers. Seine Hauptaufgaben umfassen großteils die Kontrolle von Zugriffsrechten, das Kontrollieren von Einhaltung der Datenschutzrichtlinien, sowie das Verschlüsseln oder Anonymisieren von Datenbeständen. In speziellen Fällen kann ein Datentreuhänder auch die Auswertung von Daten vornehmen. \cite{dt-bundesregierung2021datenstrategie}\cite{dt-richter2020ddvtalk}

Da - wie bereits angeführt - viele Unternehmen die Weiterleitung ihrer Daten vermeiden, ist unter der Annahme eines etablierten Datentreuhänders ein deutlich größerer Datenbestand verfügbar. Bereits heute - vor einer großen Etablierung von Datentreuhänder - verspricht das Konzept einige gesellschaftliche Vorteile: \cite{dt-richter2020ddvtalk}
\begin{enumerate}
    \item Dadurch können Datenbestände besser vernetzt werden und Zusammenhänge hergestellt werden, die zu Innovationen führen.
    \item Der Wettbewerb unter Firmen wird gestärkt, weil mit besser zugänglichen Daten auch kleinere Unternehmen, die kein Datenmonopol besitzen, ihre Produkte aufwerten können.
    \item Der individuelle Endnutzer erhält mehr Kontrolle und Transparenz über die Speicherung und Verwendung seiner Daten.
\end{enumerate}

Allerdings ist das Verständnis eines Datentreuhänders nicht eindeutig. Jürgen Kühling beschreibt den Datentreuhänder als ``ein schillerndes Wesen. Jeder kennt ihn, jeder setzt ganz eigene Hoffnungen in ihn – und jeder stellt sich doch etwas anderes unter ihm vor`` \cite{dt-kuhling2021datentreuhander}. Obwohl die Technologie eines Datentreuhänders bereits seit Jahren existiert und verwendet wird \cite{dt-hardinges2018data} ist es bisher nicht gelungen, eine konkret allumfassende Definition für die Technologie zu finden.

\subsection{Definition}
Die allgemeingültigste Definition stammt aus der Rechtswissenschaft und bezieht sich auf die Treuhandschaft im Allgemeinen. ``\textit{[Treuhandschaften sind ein] Rechtsverhältnis, bei dem eine natürliche oder juristische Person (Treugeber) einer zweiten Person (Treuhänder) ein Recht unter der Bedingung überträgt, von diesem Recht nicht zum eigenen Vorteil Gebrauch zu machen. [...] Gemeinsames Charakteristikum ist die Uneigennützigkeit und Vertrauenswürdigkeit bei der Wahrnehmung fremder Interessen bzw. die uneigennützige Ausübung von amtlichen Befugnissen.}''\cite{dt-beeck2013treuhandschaft}. Diese Treuhandschaft wurde in der Vergangenheit verwendet, um beispielsweise Ländereien zu verwalten und im Namen einer lokalen Gemeinschaft Entscheidung zu treffen. \cite{dt-hardinges2018data}. In dem Fall eines Datentreuhänders bedeutet dies konkret, dass eine Datengebende Person beim Bereitstellen ihrer Daten den Datentreuhänder dazu ermächtigt, über diese Daten zu verfügen. Darunter fällt unter anderen auch die Weitergabe der Daten, solange die im Sinne des Datengebers ist. 

\subsection{Verschieden Modelle}
Insgesamt lassen sich alle bis zum heutigen Zeitpunkt in Betrieb genommenen oder geplanten Datentreuhandsysteme wie folgt kategorisieren: Zum einen besteht die Einteilung in Customer to Business (C2B) oder Business to Business (B2B) Systeme und zum anderen die risikobasierte Einteilung nach Zentralen/Dezentraler Datenspeicherung und Freiwilliger/Verpflichtender Nutzung. (siehe Abbildung \ref{fig:dt-risikoeinteilug})

Die Unterscheidung zwischen Customer to Business (C2B) und Business to Business (B2B) Datentreuhändern basiert ausschließlich auf den interagierenden Parteien. Im Falle einer B2B Interaktion kommunizieren zwei Unternehmen die vorhandenen Daten miteinander. In diesem Fall kommt es häufig vor, dass eines der Unternehmen durch eine staatliche Behörde dargestellt wird \todo{proof}. Bei den gespeicherten Daten handelt es sich meist um personenbezogene Daten. Aufgrund dessen befassen sich B2B Datentreuhänder häufig mit der Pseudonymisierung und der Verwaltung der bereitgestellten Daten \todo{proof}. Sie sind unter anderem im Gesundheitswesen häufig vertreten. \cite{dt-blankertz2020datentreuhandmodelle}
C2B Systeme umfassen solche, bei denen ein Endnutzer die Daten generiert und diese an ein Unternehmen zur weiteren Benutzung freigibt. Ihre Aufgabe ist hauptsächlich die Unterstützung des Nutzers bei der gerechten Weiterverarbeitung seiner Daten. \cite{dt-blankertz2020datentreuhandmodelle} Hier sind dementsprechend die Pseudonymisierung der Daten sowie die Einhaltung von Datenschutzrechtlinien und einheitlicher Standards die Hauptziele des Datentreuhänders.

Des Weiteren lassen sich Datentreuhandsysteme anhand ihrer Datenspeicherung sowie Nutzung kategorisieren und Risikotechnisch bewerten. Die zentrale Speicherung der Daten bietet einige Vorteile für den Treuhänder. Sie ermöglicht es Daten vorzuverarbeiten, zu analysieren und Datenverarbeitende von dem direkten Zugang der Daten auszuschließen. Allerdings birgt die zentrale Datenspeicherung ein enormes Risiko der Datensicherheit, da hier ein Single Point of Failure entsteht. Bei einem Angriff auf einen solchen Datentreuhänder fällt es einem Angreifer somit leichter eine große Menge an Daten zu stehlen. Bei einer dezentralen Speicherung werden die Daten direkt bei den Datengebenden gelagert, was die Auswirkungen eines Angriffes erheblich senken kann. 
%Aus diesem Grund bietet eine dezentrale Datenspeicherung mehr Sicherheit vor Diebstahl. Sie zieht allerdings auch eine eingeschränkte Verarbeitung und Analyse der Daten mit sich und erhöht die Komplexität der Verwaltung.
\\

Es besteht eine weitere Unterteilung in Datentreuhandsysteme, dessen Benutzung freiwillig oder verpflichtend ist. Dabei fällt der größte Anteil an Systemen unter die freiwillige Benutzung \todo{proof}. Es gibt jedoch auch Szenarien, in denen die Verwendung einer Datentreuhand verpflichtend ist. Ein Beispiel hierfür wäre das Krebs- und Transplantationsregister aus dem medizinischen Bereich. Das Risiko steigt bei verpflichtenden Systemen, da sie meist einen wichtigen Bestandteil der Kommunikation ausmachen, der nicht umgangen werden kann. Somit sind die potenziellen Schäden, die bei einem Angriff entstehen können, höher als in einem freiwilligen System.

\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{DT-RisikoEinteilung.png}
    \caption{Risikobasierte Unterscheidung von Datentreuhandmodellen \cite{dt-blankertz2021neue}}
    \label{fig:dt-risikoeinteilug}
\end{figure}

\section{Anwendungsfälle}
\label{sec:dt-usecases}
Das mögliche Spektrum an Anwendungsfällen ist denkbar breit. In beinahe jedem Bereich, der eine große Menge an Daten benötigt oder verwaltet ist die Verwendung eines Datentreuhänders angedacht \cite{dt-blankertz2021regulierung,dt-blankertz2021neue, dt-bundesdruckereiDatentreuhänder}. Beispiele dafür sind:
\begin{itemize}
    \item \textbf{Patientendaten.} Der Datentreuhänder sorgt für eine Pseudonymisierung von Patientendaten zur Bereitstellung an Forschungseinrichtungen. Hierbei behält der Patient die Kontrolle über seine Daten und kann selbst entscheiden, mit wem seine Daten geteilt werden.
    \item \textbf{Autonomes Fahren.} Beim autonomen Fahren werden enorm viele Daten generiert, die seit 2017 per Gesetz gespeichert werden müssen \cite{dt-bundesdruckereiDatentreuhänder}. Leider ist die Zugehörigkeit der Daten rechtlich weder dem Autohersteller noch dem Autoinhaber zuzuschreiben \cite{dt-richter2020ddvtalk}. An dieser Stelle kann ein Datentreuhänder die Kommunikation erleichtern und exklusiven Zugang von beispielsweise Versicherungen oder Automobilkonzernen ausschließen.
    \item \textbf{E-Government.} Durch die Verwendung eines Datentreuhänders können bei der behördlichen Verwaltung von Bürgerdaten große Fortschritte erzielt werden. Unter anderem müssen notwendige Informationen aus anderen Registern für Verwaltungsvorgänge nicht mehr vom Bürger bereitgestellt werden. Der Bürger gibt lediglich seine Einwilligung zum Abruf der Daten zu Beginn des Verwaltungsvorgangs. Auf diese Weise können Verwaltungsvorgänge erheblich effizienter Ablaufen.
    \item \textbf{KI-Datenpools.} Eines der größten Probleme bei Entwicklung von KI-Software ist der Zugang zu einer ausreichend großen Menge an Trainingsdaten. Ein Datentreuhänder kann solche Daten, die zur Verwendung für KI-Training freigegeben wurden, sammeln und pseudonymisiert an mehrere Interessierte verteilen. Dadurch entsteht ein einheitlicher Zugang zu Trainingsdaten der gleichzeitig nur freigegebene Daten beinhaltet und so rechtlichen Streit über die Urheberschaft aus dem Weg geht.
    \item \textbf{Industrie.} In der Industrie besteht eine hohe Abhängigkeit von Warenbewegungen, seien es in Lieferketten, Logistik oder Handel. Durch die Verwendung eines Datentreuhänders können diese Informationen pseudonymisiert an Warenempfänger weitergegeben werden. Vor allem in diesem Bereich besteht durch die Zusammentragung an Lieferinformationen in Kombination mit Algorithmen der Graphentheorie ein großes Innovationspotential.
    \item \textbf{PIMS.} Personal Information Management Systeme befassen sich grundsätzlich mit der Wahrung von personenbezogenen Daten und bieten ihren Nutzern mehr Kontrolle über diese.  Datentreuhänder sind für solche Systeme vor allem von Vorteil, da sie im Umgang mit personenbezogenen Daten dem Nutzer wieder die Kontrollen über seine Daten zurückgeben.
\end{itemize}

Der erste Datentreuhänder entstand bereits im Jahre 2006 in England. Das Thema Datentreuhänder wurde in den letzten Jahren immer mehr zum Trend \cite{dt-richter2020ddvtalk}. Die ``UK Biobank`` ist eine biomedizinische Datenbank, die sowohl medizinische Daten als auch biologische Proben von einer halben Millionen Teilnehmer aus Großbritannien speichert \cite{dt-hardinges2018data}. Die gespeicherten Daten sind pseudonymisiert und werden ausschließlich an Forscher im Feld der Medizin weitergegeben, was die UK Biobank zu einem Paradebeispiel für einen Patientendatentreuhänder macht.


\section{Bestehende Anreize}
Insgesamt bringt die Verwendung eines Datentreuhänders keine direkten Nachteile mit sich. Wenn Daten ohnehin geteilt werden oder werden müssen, behält der Nutzer bei der Speicherung der Daten über einen Datentreuhänder mehr Kontrolle über die Verwendung seiner geteilten Daten, als im Vergleich mit dem direkten Teilen mit Unternehmen. Durch den Datentreuhänder wird ihm ermöglicht, zu einem beliebigen Zeitpunkt das weitere Teilen seiner Informationen einzustellen. Vermutlich teilen deswegen Privatpersonen ihre Daten lieber mit Datentreuhändern als auf direktem Weg. \cite{dt-tresor24study}

Allerdings gibt es nur wenige Vorteile, die die freiwillige Benutzung eines Datentreuhänders reizvoll machen. Bei freiwilligen C2B Datentreuhändern liegt die Entscheidung für oder gegen die Nutzung des Treuhänders beim Nutzer. Es ist also an ihm abzuwägen, ob die Verwendung ausreichend Vorteile liefert. Im Fall von PIMS-Treuhändern wird die Verwendung von manchen als erstrebenswert angesehen, da der Nutzer mehr Kontrolle über die Verbreitung von persönlichen Daten erhält und selbst entscheiden kann, mit wem diese geteilt werden. Die Erkenntnisse von Jai et al. \cite{dt-jai2016privacy} zeigen hingegen, dass vor allem jüngere Erwachsene weniger Wert auf den Schutz ihrer persönlichen Daten legen.

Direkte Anreize zur Verwendung einer solchen Software sind bisher kaum präsent. An der Weitergabe der persönlichen Daten hat nur das Business einen konkreten Mehrwert \todo{proof}. Der Nutzer, der seine Daten freigibt, erhält keine Kompensation in irgendeiner Form. Folglich kann es für einen freiwilligen Datentreuhänder mühsam sein, neue Nutzer zu gewinnen und die Technologie als solche auszubauen.


%==================================================================================================


\chapter{Angreifermodelle und Anforderungen}
In diesem Kapitel werden zuerst die Angreifermodelle für das später entworfene Bezahl- und Reputationssytems definiert und anhand ihrer die Anforderungen für die Systeme aufgestellt.
\label{chap:req}
\section{Definition der Angreifermodelle}
Angreifermodelle sind ein in der Informationssicherheit weit verbreitetes Konzept, mit dem sich die Stärke eines Systems gegen Angriffe eines theoretischen Angreifers zeigen lässt. Ein Angreifermodell besteht aus Angreiferzielen, die ein Angreifer mit seinem Angriff erreichen möchte. Angreiferannahmen die Aussagen über die Ressourcen und das Umfeld des Angreifers aussprechen. Und Angreiferfähigkeiten welche dem Angreifer eine Liste an möglichen Angriffsmethoden zu verfügung stellen. Zusammen ergibt sich aus diesen drei Spezifikationen ein Angreifer dessen macht gerade so nicht ausreicht, damit der Angreifer sein definiertes Ziel erreicht. Eine ausführliche Erklärung von Angreifermodellen folgt in Kapitel \ref{chap:auswertung}. Hier werden fünf Angreifermodelle für die unterschiedliche Akteure der später eingeführten Systeme aufgestellt.\\

Die Angreiferfähigkeiten beschränken sich bei allen folgenden Angreifermodellen auf die Verwendung von polynomialzeit Algorithmen und das Verfügen über unbegrenzten Speicherplatz.
\begin{enumerate}
    \item \textbf{Neugierig aber ehrlicher Datentreuhänder.} Das Ziel des neugierigen Datentreuhänders ist, anhand der über ihn laufenden Kommunikation ausreichend Informationen über den Datengebenden und den Datennutzenden zu erhalten, um die Handelsbeziehungen zwischen den beiden Akteuren verfolgen zu können. Er muss sich an die im Protokoll vorgeschriebenen Schritte halten und darf nur anhand der mitgeschnittenen Nachrichten Analysen tätigen.
    \item \textbf{Bösartiger Datengebender.} Ein bösartiger Datengebender möchte das System ausnutzen und ohne (oder möglichst wenige) Daten zu teilen so  viele Coins wie möglich erhalten. Er darf vom vorgegebenen Protokoll abweichen und kann über die erhaltenen Informationen frei verfügen, sowie diese öffentlich teilen.
    \item \textbf{Bösartiger Datennutzender.} Bösartige Datennutzende zielen darauf ab, die Identität der Datengebenden über mehrere Handel zu verlinken und so ein Pseudoyn mit allen von diesem Datengebenden erhaltenen Daten zu erstellen. Zusätzlich möchte er für das Empfangen von Daten keine Coins ausgeben. Der bösaritge Datennutzende darf ebenfalls vom Protokoll abweichen und kann vorgeschriebene Berechnungswege ersetzen. Er kann Analysen anhand der mitgeschnittenen Nachrichten erstellen.
    \item \textbf{Neugierig aber ehrlicher Exchange.} In dem in den Abschnitten \ref{system:coingeneration} und \ref{system:payment} eingeführten Systemen, können Coins zum bezahlen des Datengebenden bei einem Exchange erstellt und eingelöst. Genauere Details werden in den jeweiligen Abschnitten genannt. Das Ziel des Exchanges ist, die ausgestellten Coins beim späteren einlösen wieder zu erkennen und so Schlüsse über die Beziehung zwischen Datennutzenden und Datengebenden zu ziehen. Außerdem möchte er einen Überblick darüber haben, welcher Datennutzende wie viele Coins erstellt hat und wie viele er davon bereits ausgegeben hat. Der Exchange ist in dem meisten Teilen an das Protokoll gebunden und kann nur an einer Stelle von diesem Abweichen. Er kann ebenfalls Analysen über die mitgeschnittenen Daten erstellen und probieren aus ihnen Informationenen zu gewinnen.
    \item \textbf{Außenstehender Angreifer.} Ein außenstehender Angreifer ist nicht in Kommunikation involviert, sondern möchte anhand sämtlicher übertragener Nachrichten zwischen zwei Akteuren herausfinden, wer mit wem kommuniziert und was in der Nachricht enthalten ist. Dafür kann er alle Nachrichten die innerhalb der Protokoll ausgetauscht werden mitschneiden. Er kann auch mit den empfangenen Nachrichten selbst die Kommunikation mit einem Akteur aufnehmen und sich als ein Teilnehmer der Kommunikation ausgeben.
\end{enumerate}

\section{Funktionale Anforderungen}
\label{enum:req:funktional}
\begin{enumerate}
    \item Ein Bezahlsystem ermöglicht es einem Datengebenden Geld für seine Daten zu erhalten.
    \item Ein Reputationswert gibt vor Erwerb der Daten durch den Datennutzenden eine Einschätzung über deren Qualität.
    \item Nach Erhalt von Daten muss ein Datennutzender den Datengebenden für die erhaltenen Daten bezahlen und diese Bezahlung auf Nachfrage nachweisen können.
    \item Nach Abschluss der Transaktion kann ein Datennutzender den entsprechenden Datengebenden aufgrund der Qualität der übermittelten Daten bewerten.
    \item Ein Datengebender muss eine Bewertung seiner Daten ermöglichen.
    \item Ein Datennutzender kann pro Austausch nur genau eine Bewertung für einen Datengebenden abgeben. Mehrfache Bewertungen ist nur im Fall von mehrfachem Erwerb möglich.
\end{enumerate}

\section{Nicht funktionale Anforderungen}
\label{enum:req:nichtfunktional}
\begin{enumerate}
    \item \textbf{Anonymität.} Die Identität des Datengebenden darf durch den Austausch von Zahlungsmitteln oder durch dessen Reputation nicht offengelegt werden.
    \item \textbf{Unverkettbarkeit.} Mehrere Transkationen eines Datengebenden dürfen keine Informationen über den Zusammenhang dieser aufweisen. 
    \item \textbf{Zeitsensitivität.} Der Bezahlvorgang muss in vernachlässigbarer Zeit geschehen.
    \item \textbf{Skalierbarkeit.} Die Rechenzeit des Systems soll bei linear steigender Menge an Datengebenden und Datennutzenden auch mit linearem Zeitaufwand zunehmen.
    \item \textbf{Vertraulichkeit.} Die kommunizierten Daten dürfen nicht durch unbefugte Dritte ausgelesen werden können.
    \item \textbf{Integrität.} Die kommunizierten Daten dürfen nicht unbemerkt durch unbefugte Dritte verändert werden.
\end{enumerate}

\chapter{Verwandte Arbeiten}
In diesem Kaptiel werden bestehende Arbeiten vorgestellt, die eine dichte Verbindung zu dem Thema dieser Bachelorarbeit haben. Dafür wird das Produkt der Arbeit erklärt und anschließend erläutert warum diese Arbeiten in dem Umfeld eines Datentreuhänders nicht eingesetzt werden können. Die Arbeiten beziehen sich zuerst auf weitere Bezahlsystem und behandeln später Bausteine die für die Konstruktion des hier dargelegten Bezahlsystems essentiell sind.

\section{GNU Taler}
\label{subsec:gnu}
Das im Paper ``Enabling Secure Web Payments with GNU Taler`` von J. Burdges et al. eingeführte Zahlungssystem GNU Taler ist ein elektronisches Online-Zahlungssystem, das Datenschutz für Customer und Mechanismen zur steuerlichen Nachverfolgung für Merchants bietet \cite{gnu-burdges2016enabling}. Es verwendet einen Exchangeservice, um Münzen mithilfe von blinden Signaturen zwischen Nutzern und Händlern zu transferieren. Im Folgenden werden diese Münzen als Taler bezeichnet. Das System basiert auf vier übergeordneten Rollen, dessen Interaktion grob in Abbildung \ref{fig:gnu_taler_overview} skizziert ist. Der Customer möchte ein Gut oder eine Dienstleistung bei dem Merchant erwerben und bezahlt diesen dafür mit Talern, die er beim Exchange erworben hat. Der Merchant kann die erhaltenen Taler wieder beim Exchange für herkömmliche Währungen eintauschen. Ein Auditor überprüft währenddessen die Liquidität des Exchange, um sicherzustellen, dass dieser auch bei Datenverlust von Talern noch in der Lage ist, allen Beteiligten Auszahlungen zu ermöglichen.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{gnu_system_graphic.png}
    \caption{Grundlegender Ablauf des GNU Taler Systems \cite{gnu-burdges2016enabling}}
    \label{fig:gnu_taler_overview}
\end{figure}

\textbf{Taler abheben.} Damit ein Customer Geld auf sein Wallet laden kann, muss er sich zuerst bei seiner Bank anmelden. Sollte die Bank GNU Taler native unterstützen, so kann der Customer in einem Formular eine Summe auswählen, die er in Taler übertragen möchte und einen Exchangeservice, über welchen der Tausch abgewickelt wird. Nachdem der Customer die Transaktion bestätigt hat, wird die ausgewählte Summe transferiert, der Exchangeservice signiert die äquivalente Summe an Talern und überträgt diese in das Wallet des Customers.\\

\textbf{Taler ausgeben.} Gehen wir von der Situation aus, dass ein Customer bei einem Merchant (hier ein Onlineshop) etwas erwerben möchte. Nach der Auswahl des Produktes und GNU Taler als Zahlungsmittel erstellt der Merchant einen Zahlungsvertrag, der Details wie den Gesamtpreis, mögliche offene Umwandlungsgebühren und akzeptierte Exchangeservices beinhaltet und sendet diesen an das Wallet des Customers.  Wenn der Customer daraufhin die Zahlung übermittelt, so leitet der Merchant die erhaltenen Taler direkt an den Exchange weiter. Wenn der Exchange den Eingang bestätigt, so kann der Merchant dem Customer die Transaktion bestätigen und der Kauf ist somit abgeschlossen.\\


In dem Treuhändermodell eignet sich GNU Taler aber nur teilweise als Zahlungssystem. Der Datengebende stellt dabei den Merchant dar, der seine Daten als digitales Gut anbietet. Der Datennutzende stellt hier die Rolle des Customers dar und möchte diese Daten erwerben. Sollte der Datengebende der Anfrage des Datennutzende zustimmen, so würde er einen Zahlungsvertrag formulieren, um den Anspruch auf seine Vergütung zu formalisieren. Allerdings soll der Datengebende im Datentreuhändermodell so gut wie möglich vor Informationsgewinnung geschützt werden. Bei dem von GNU Taler vorgeschlagenen Prozess wird jedoch die Identität des Datengebenden nachverfolgbar, während der Datennutzenden anonym bleibt. Zusätzlich besteht eine direkte Kommunikation zwischen Datengebenden und Datennutzenden, was weitere schützenswert Information über die Identität des Datengebenden (beispielsweise seine IP-Adresse) preisgibt.

\section{Bitcoin}
\label{sec:bitcoin}
Die Idee hinter Bitcoin entstand 2008 durch eine Person oder Gruppe mit dem Namen Satoshi Nakamoto. Heute ist Bitcoin die mit Abstand weit verbreiteteste Onlinewährung weltweit \cite{btc-beginnerGuide}. Sie basiert auf einem verteilten öffentlichen Register, das alle Transaktionen pseudonymisiert für jeden einsehbar macht und speichert. Dieses Register ist auch als Blockchain bekannt.

\begin{figure}
    \centering
    \label{fig:btc_blockchain}
    \includegraphics[width=0.5\linewidth]{BitcoinBlockchain.png}
    \caption{Blockchain mit Transaktionen \cite{btc-nakamoto2008bitcoin}}
\end{figure}

Die Blockchain ist eine Kette an Blöcken, die jeweils den Hash des vorherigen Blocks und neue Transaktionen speichert. Durch den Hash des vorherigen Blocks entsteht eine Kette, in der jeder Block Informationen über seinen Vorgänger speichert, wie in Abbildung \ref{fig:btc_blockchain} zu sehen ist. Ein neuer Block entsteht durch einen sogenannten Proof of Work. Dieser ist das Wissen über eine Zufallszahl, deren Hash mit $x$ 0 bits beginnt, welche ausschließlich durch das wiederholte Ausprobieren von Zufallszahlen gefunden werden kann. Dieser Vorgang wird als Bitcoin Mining bezeichnet. Sobald eine solche Zahl gefunden wird, kann der aktuelle Block abgeschlossen werden und alle folgenden Transaktionen werden in dem nächsten Block gespeichert \cite{btc-nakamoto2008bitcoin}.

Der Algorithmus, der bestimmt wie schwer das Erbringen des Proof of Works ist, kann jederzeit dynamisch an die Rechenleistung der Miner angepasst werden, so dass im Schnitt alle 10 Minuten ein neuer Block gefunden wird \cite{btc-Zaghloul2019Bitcoin}. Um also eine vergangene Transaktion auf der Blockchain zu verändern, müsste ein Angreifer für jeden darauffolgenden Block selbst einen Proof of Work berechnen. Ein Angreifer kann deswegen nur eine vergangene Transaktion ändern, wenn er allein mehr Rechenleistung besitzt als alle anderen Miner zusammen. \\

In dem Moment, in dem ein Block abgeschlossen und der nächste begonnen wird, sind alle Transaktionen auf dem abgeschlossenen Block ein Mal bestätigt. Das bedeutet, dass keine der Transaktionen einen Coin zum zweiten Mal ausgibt. Dies ist eine essenzielle Sicherheitsmaßnahme von Blockchain Kryptowährungen da Blockchain dezentralisiert und ohne neutralen Überprüfer funktioniert. Es ist also an allen Beteiligten, die pseudonymisierten Transaktionen des Blocks zu überprüfen. Sollte ein Angreifer die Zufallszahl finden und vor Abschluss des Blocks noch eine doppelte Ausgabe hinzufügen, so kann diese Transaktion erst festgestellt werden, wenn bereits neue Transaktionen in dem nächsten Block hinzugefügt werden. Das zeigt, dass nur weil eine Transaktion bestätigt ist, sie nicht direkt vertrauenswürdig ist. Im Fall von Bitcoin wird empfohlen, 6 weitere Blöcke abzuwarten bis eine Transaktion wirklich abgeschlossen ist \cite{btc-Zaghloul2019Bitcoin}. In Kombination mit einer durschnittlichen Berechnungsdauert von 10 Minuten dauert es also ca. eine Stunde, bis eine Transaktion auf der Blockchain als Sicher angesehen wird.
Durch den enormen Rechenaufwand, der benötigt wird um einen Block abzuschließen, kann grob überschlagen werden, wie viel Energie in eine einzelne Bitcointransaktion fließt. In \cite{btc-energyConsumption} wird eine Transaktion auf 703,25 kWh geschätzt, was ca 470.000 VISA Transaktionen entspricht.\\

Allein die lange Bestätigungsdauer einer Bitcointransaktion schließt es bereits für die Verwendung in diesem System aus, da eine Stunde nicht mehr als vernachlässigbare Zeit angesehen werden kann und somit nicht Zeitsensitiv ist. Hinzu kommt der gigantische Stromverbrauch, welcher die Skalierbarkeit von Bitcoin selbst in Frage stellt. 


\section{Ethereum}
\label{sec:ethereum}
Ethereum ist die Blockchainanwendung hinter der zweit meist verbreitetesten Kryptowährungen Ether \cite{eth-marketCapitalisation}. Es wurde 2013 von Vitalik Buterin erfunden und ist eine Plattform, die es Entwicklern ermöglicht Anwendung auf der Blockchain zu entwickeln. Es liefert eine Turing-vollständige Programmiersprache die es Entwicklern erlaub, eigene Währungen in unter 20 Zeilen Code zu schreiben \cite{eth-buterin2013ethereum}. Sämtliche dort geschriebene Währungen oder sogenannte Smart Contracts werden über die Ethereum Blockchain pseudonymisiert öffentlich zur Verfügung gestellt. 

Durch die Verwendung der Blockchain decken sich einige Eigenschaften mit Bitcoin. Es besteht genauso aus einer Reihe an Blöcken, die kontinuierlich ihren Vorgänger referenzieren. Bis 2022 nutzte Ethereum ebenfalls einen Proof of Work Ansatz. Doch seit 2022 basiert Ethereum auf einem sogenannten Proof of Stake Konzept \cite{eth-explainerInvestopia}. Das bedeutet, dass es eine Gruppe an Validierern gibt, welche die Transaktionen innerhalb der Blöcke überprüfen. Um ein Validierer zu werden, muss ein Starteinsatz von 32 Ether gezahlt werden. Alternativ kann sich ein Nutzer einem Validiererpool anschließen und einen kleineren Starteinsatz zahlen. Dafür muss er jedoch die erzielten Gewinne teilen. 

Die Aufgabe eines Validierers ist es, unzulässige Transaktionen festzustellen. Im Fall eines Angriffs auf einen Block wird der Block von Gasper (Einer Mischung des Casper-FFG Protokolls und LMD Ghost Algorithmus \cite{eth-buterin2020combining}.) markiert. Anschließend entscheiden die Validierer, ob der Block zugelassen oder blockiert werden soll. Validierer, die sich bösartig Verhalten, werden dadurch bestraft, dass ihr Starteinsatz nach und nach ``verbrannt`` wird. Mit verbrannt ist gemeint, dass der Einsatz an ein Wallet ohne Private-Key gesendet wird, was die Coins unwiderruflich unzugänglich macht. Durch diesen alternativen Ansatz kann der große Rechenaufwand von Bitcoin umgangen werden.\\

Die Verwendung einer Blockchain stellt hier wieder das Problem der Zeitsensitivität. Zwar dauert das Erstellen eines Blocks bei Ethereum nur 12 Sekunden \cite{eth-timePerBlock}. Dafür wird allerdings eine Mindestanzahl von 30 Blöcken empfohlen, bevor eine Transaktion für gültig erklärt wird. Somit entsteht eine Wartezeit von ca sechs Minuten, was bei weitem besser ist als Bitcoin. Trotzdem sind sechs Minuten keine vernachlässigbare Zeit, weshalb auch Ethereum nicht für dieses System verwendet werden kann.


\section{Privacy Pass}
\label{sec:privacy-pass}
Privacy Pass ist eine Browsererweiterung, die den Komfort der Internetbenutzung für Nutzer eines VPN erhöht. Ein VPN bietet einige Vorteile in der regulären Kommunikation über das Internet. Beispielsweise erhöht die Nutzung die Anonymität des Nutzers, da dessen private IP-Adresse so nur dem VPN-Anbieter bekannt ist und nicht dem Webseitenbetreiber. Allerdings gibt es auch Nachteile die häufig übersehen werden \cite{pp-Abbas2023Security}. Einer dieser Nachteile ist entsteht durch das Teilen einer IP-Adresse mit vielen weiteren Nutzern. So genügen wenige bösaritge Nutzer die den VPN verwenden um ihre Spuren zu verwischen, damit die IP-Adresse von einem Content Delivery Network einen schlechten Ruf erhält. Ein Content Delivery Network (kurz CDN) ist dafür zuständig, häufig angefragte Webseiten wie Google.de oder Netflix.com in seinem Cache aufzubewahren und so die Zugriffszeit, welche durch physikalisch große Distanzen zwischen Nutzer und Server, entsteht zu verkürzen \cite{pp-cdn}. Zusätzlich liefert ein CDN eine Menge an Sicherheitsfunktionen, wie unter anderem IP-Adressen mit schlechtem Ruf ein CAPTCHA präsentieren, um Botzugriffe zu verhindern \cite{pp-Ghaznavi2021Content}. Daraus resultiert, dass ein regulärer Nutzer eines VPNs erheblich mehr CAPTCHAs lösen muss als ein Nutzer, der keinen VPN verwendet \cite{pp-davidson2018privacy}.

\subsection{Umgehen vom CAPTCHAs}
Die Erweiterung ermöglicht es vorab ein CAPTCHA zu lösen und damit eine Menge an Token zu erhalten. Solange ein Nutzer über mindestens einen Token verfügt kann er das nächste Mal, wenn ein CDN ihn aufgrund eines schlechten IP-Rufwertes zum Lösen eines CAPTCHAs auffordert, stattdessen einen Token einlösen und kann die Aufgabe so überspringen. Dadurch erhöht sich die Nutzerfreundlichkeit unter der Verwendung eines VPNs, da die Anzahl an zu lösenden CAPTCHAs rapide sinkt. \cite{pp-davidson2018privacy}

\subsection{Funktionsweise}
Das System ist in eine sogenannte Signierphase und Einlösephase aufgeteilt. Die Signierphase startet, nachdem der Nutzer erfolgreich ein CAPTCHA gelöst hat. Sie ist dafür zuständig, dem Nutzer eine Anzahl an Token auszustellen, die durch den Server signiert sind. Die Einlösephase beginnt, wenn ein CDN ein CAPTCHA für den Zugang zu einem Webinhalt fordert. Bei ihr wird einer der gespeicherten signierten Token eingetauscht, um die Lösung des CAPTCHAs zu überspringen. 

\paragraph{Signierphase.} Erstellen und signieren von Token
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{pp_signphase.png}
    \caption{Signierphase von Privacy Pass \cite{pp-davidson2018privacy}}
    \label{fig:pp-signingphase}
\end{figure}
Die Abbildung \ref{fig:pp-signingphase} zeigt die Berechnung beim Durchlaufen einer Signierphase. Zuerst erstellt der Nutzer \textit{C} (Client) einen zufälligen Tokenseed $t$ mit $t {\in}_R \mathbb{Z}_q $. Daraus generiert er Token $T$ beispielsweise mit einer Hashfunktion und blendet diesen mit $r$ wie in Abbildung \ref{sec:blindSig} beschrieben, um $\widetilde{T}$ zu erhalten. Dieser geblendete Token wird nun an den Server \textit{S} gesendet, damit dieser in signieren kann. Beim Server angekommen beginnt dieser damit, den Token mit seinem privaten Schlüsselt $sk$ zu signieren. Anschließend erstellt er einen sogenannten Batch Discrete Log Equivalence Proof (BDLEQ), um dem Nutzer zu beweisen, dass er für jeden Nutzer einen gleichen Private-Key verwendet. Sollte er für jeden Nutzer einen eigenen Private-Key benutzen, so kann er den Nutzer über längere Zeit deanonymisieren, da er die in der Signierphase erhaltenen Token mit denen der Einlösephase verlinken kann. Der signierte Token und der BDLEQ werden wieder an den Nutzer gesendet, dieser prüft die Korrektheit des Beweises, unblendet den signierten Token und speichert ihn für spätere Verwendung. 

\paragraph{Einlösephase.} Signierten Token einlösen\\
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{pp-redemptionphase.png} 
    \caption{Einlösephase von Privacy Pass \cite{pp-davidson2018privacy}}
    \label{fig:pp-redemptoinphase}
\end{figure}
Hier zeigt Abbildung \ref{fig:pp-redemptoinphase} den Ablauf der Einlösephase, in der der Nutzer damit beginnt, einen gespeicherten signierten Token auszulesen und einen anfragenabhängigen Wert $R$ zu berechnen. Dieser könnte einfach die Domain der Anfrage sein. Er generiert einen shared Key $K$ aus dem Tokenseed und dem signierten Token und verschlüsselt $R$ mit $K$ als Key. Daraufhin sendet er das Tupel aus Tokenseed $t$ und $s\leftarrow MAC_{K}(R)$ mit shared Key verschlüsseltem $R$ an den Server. Der Server prüft, ob $t$ bereits für eine vorherige Anfrage verwendet wurde. Falls dies nicht der Fall ist, berechnet er auf Grundlage von $t$ alle Schritte des Nutzers und erhält so ein $s'$. Sollte $s'=s$ gelten, dann ist der Token valide, das CAPTCHA kann übersprungen werden und der Nutzer erhält Zugriff auf die angefragt Webressource.

\paragraph{Batch Discrete Log Equivalence Proof.}
Beim dem BDLEQ handelt es sich um einen Zero Knowledge Proof. Zero Knowledge Proofs sind ein in der Kryptographie auftretendes Beweismuster, dass das Wissen über einen Wert belegen kann ohne den Wert tatsächlich zu nennen. Der hierverwendete Discrete Log Equivalence Proof kann wie sich aus dem Namen ableiten lässt dazu verwendet werden, die Gleichheit von zwei diskreten Logarithmen zu zeigen. Für die genau Anwendung wird hier auf die Arbeit von Davidson et al. \cite{pp-davidson2018privacy} verwiesen. Dieser Beweis wird aus dem Grund erstellt, dass ein CDN ansonsten für das Signieren von jedem Token ein unterschiedliches Schlüsselpaar verwenden kann. Die Folgenden davon sind, eine mögliche Deanonynmisierung, da der CDN beim Einlösen des Tokens anhand des verwenden Signierschlüssels der einmalig ist, den Signierzeitpunkt und zugehörigen Nutzer bestimmen kann. Der DLEQ liefert dem Nutzer hier die Sicherheit, dass der diskrete Logarithmus des zum signieren verwendeten Private-Keys der gleiche ist, wie ein von CDN öffentlich bekannt gegebener diskreter Logarithmus. Davidson et al. beschreibt zudem einen Weg den DLEQ in einer Sammelform zu formulieren, sodass ein Beweis für eine Liste an Token gilt \cite{pp-davidson2018privacy}, was Rechenaufwand spart.\\\\

Im Grunde lässt sich Privacy Pass gut auf die Verwendung im Datentreuhändermodell anwenden. Unter den Annahmen, dass ein Datennutzender hier ein Nutzer ist, kann er Token bei dem Datentreuhänder erwerben, speichern und zu einem späteren Zeitpunkt wieder ausgeben. Da die Token blind signiert werden, wird vermieden, dass der Datentreuhänder die in den unterschiedlichen Phasen verwendeten Token zueinander verlinken kann und Zusammenhänge zwischen Einlösen und Ausgeben ziehen kann. Der Datentreuhänder kann eine weitere überprüfende Instanz verwenden wie in \cite{pp-davidson2018privacy} beschrieben wird, um den Aufwand der Überprüfung auszulagern. \\
Einige Punkte sprechen jedoch gegen die direkte Verwendung von Privacy Pass. 
\begin{enumerate}
    \item Die Token haben keinen Wert. Bei Bezahlungsmittel ist es essenziell einen bestimmten Preis bezahlen zu können. Dafür wären entweder mehrere unterschiedliche Tokens von Nöten oder Token, die einen monetären Wert gespeichert haben. Bei der Speicherung eines monetären Wertes erbringt sich das Problem der Beweisbarkeit. Wenn ein Token geblendet ist und für den Datentreuhänder nicht lesbar ist, wie kann sichergestellt werden, dass der richtige Wert eingehalten wurde und der Datennutzende sich nicht mehr Geld aufschreibt als ihm zusteht. Ansonsten kann nur ein Vielfaches von einem Token gezahlt werden was dazu führt, dass es keine präzise Preisvergabe gibt oder bei jeder Transaktion eine große Menge an Token validiert werden müssen.
    \item Ein Nutzer interagiert sowohl zum Einlösen als auch zum Ausgeben nur mit dem Server und nicht mit einem Verkäufer, dem er seine Token im Tausch anbietet. Es existiert hier also kein 3. Akteur wie bei GNU Taler \ref{subsec:gnu} der erhaltene Token einlöst.
    \item Die Token können ähnlich wie bei GNU Taler \ref{subsec:gnu} nicht direkt an den Verkäufer weitergegeben werden, da dadurch eine direkte Verbindung zwischen Datennutzenden und Datengebenden entsteht, welche schützenswerte Informationen offen legt.
\end{enumerate}

\section{Privacy-Preserving Reputation Management}
\label{subsec:rep}
In ihrem Paper beschreiben R Petrlic et al. ein Reputationssystem um Nutzern den Dienst eines Dienstleisters anonym bewerten zu lassen und so anderen Nutzern eine Einschätzung über die Qualität der Dienstleistung zu geben \cite{petrlic2014privacy}. Es werden 3 Rollen charakterisiert. Ein Reputation Provider $RP$, der sich um das Verwalten der verschiedenen Reputationswerte kümmert. Eine Menge an Service Providern $SP$, die einen Dienst anbieten der durch Nutzer bewertet werden soll. Und zuletzt eine Menge an Nutzern $U$, die die Dienstleistung der Service Provider bewerten. Wobei keiner der Nutzer gleichzeitig ein Service Provider $SP$ sein kann, $U \cap SP = \varnothing$. 

Der im Paper beschriebene Ablauf des Bewertens eines $sp \in SP$ durch einen Nutzer $u \in U$, umfasst grob die Erstellung eines Schemas für einen Bewertungsvektors durch $sp$, welcher von $u$ später verwendet wird, um den $sp$ zu bewerten. Nach dem $sp$ dieser Vektor mit dem $RP$ kommuniziert wurde, kann $u$ eine Dienstleistung von $sp$ in Anspruch nehmen. Dieser antwortet, zusätzlich zur Erbringung der Dienstleistung, mit einer Beschreibung des Bewertungsvektors, einem Schlüsselpaar und einem Token. Dank der Beschreibung kann der Nutzer selbst einen Bewertungsvektor erstellen, in welchen er seine Bewertung der Dienstleistung einbaut. Im Anschluss wird dieser mit dem Schlüsselpaar verschlüsselt, signiert und zusammen mit dem signierten Token an den $RP$ gesendet. Der Token dient hier zur Erkennung von doppelten Bewertungen. 

Die Berechnung der Reputation ist in Zeitslots eingeteilt, damit ein $sp$ nicht in der Lage ist einen alten Reputationswert anzugeben. Wenn nun ein Nutzer $u$ den Reputationswert eines $sp$'s einsehen möchte und der Wert für den gewünschten Zeitraum noch nicht bestimmt wurde, so muss dieser zwischen $RP$ und $sp$ berechnet werden. Hierfür bestimmt $RP$ die Summe aller verschlüsselten Bewertungsvektoren für den Zeitraum und sendet diese zusammen mit weiteren Prüfwerten an $sp$. Dieser kann die übermittelten Werte prüfen und auf eine Blacklist hinzufügen, um Replay Attacken von $RP$ auszuschließen. Wenn die Überprüfung gelingt, signiert $sp$ die Summe der Vektoren zusammen mit einer ID und verifiziert somit den neuen Reputationswert an $RP$. 

Bei einer Anfrage des Reputationswertes von $sp$ durch $u$, schickt der $sp$ eine Reihe an Werte zu $u$. Diese erlauben es $u$, den Bewertungsvektor zu interpretieren und zu prüfen, dass der übermittelte Werte sowohl aktuell, als auch nicht beeinflusst wurde. 
Das Konzept von Petrlic et al. bietet unter anderem Schutz vor: 
\begin{enumerate}
    \item \textbf{Whitewashing}, bei dem sich ein $sp$ mit schlechter Reputation als neuer $sp$ ausgeben kann, um somit den Wert zurücksetzen kann.
    \item \textbf{Transaction-independent Ratings}, bei denen ein Nutzer die Dienstleistung bewerten kann, obwohl er besagte Dienstleistung nicht in Anspruch genommen hat.
    \item \textbf{Sybil Attacks}. Ein Nutzer bewertet eine Dienstleistung unter mehreren Identitäten und täuscht so seine Meinung als Gruppenmeinung vor.
    \item \textbf{Delta Analysis}. Eine teilweise Deanonymisierung des Nutzers durch Vergleichen von gesammelten Bewertungen in unterschiedlichen Zeitabständen.
\end{enumerate} 
In der vorliegenden Situation kann das Konzept zu großen Teilen verwendet werden. Die Rollenverteilung bleibt unter den Zuweisungen von Service Provider zu Datengebenden, Reputation Provider zu Datentreuhänder und User zu Datennutzenden bestehen. Allerdings ist das Konzept darauf ausgelegt, dass zu Beginn eine Kommunikation zwischen dem Datengebenden und Datennutzenden besteht, so dass der Reputationswert direkt durch den Datennutzenden abgefragt werden kann. An dieser Stelle muss das Konzept etwas abgewandelt werden, da zu keinem Zeitpunkt während der Durchführung eine direkte Kommunikation bestehen soll. Stattdessen soll der Austausch des Reputationswertes direkt über den Treuhänder ablaufen.

\section{Blinde Signaturen}
\label{sec:blindSig}
Das von David Chaum im Jahre 1983 veröffentlichtes Paper ``Blind signatures for untraceable payments`` beschreibt den theoretischen Ansatz, dass ein Nutzer eine verifizierbare Signatur für eine Nachricht erhält, ohne dass der Unterzeichner den Inhalt der Nachricht kennt. \cite{chaum1983blind}. Ein Beispiel hierfür wäre ein Zahlungsdienstleister, der eine neuen Coin in dem Umlauf bringen möchte. Dafür sendet er seinen Reputationswert und den unkenntlich gemachten Coin an eine zentrale Institution. Wenn diese den Reputationswert als hoch genug ansieht und somit den Zahlungsdienstleister als vertrauenswürdig erkennt, so kann sie den Coin blind signieren und an den Dienstleister zurückschicken. Wenn nun ein späterer Inhaber des Coins prüfen möchte, ob sein Coin von einem vertrauenswürdigen Dienstleister erstellt wurde, so kann er die blinde Signatur mit dem Public-Key der Institution entschlüsseln. Das Ergebnis dieser Berechnung zeigt, dass die Institution den Coin tatsächlich signiert hat und sie dem Coinaussteller vertraut. Der hierbei essenzielle Punkt ist, dass diese Institution nicht weiß, was sie unterschreibt. Somit kann die Institution die Beziehung des Dienstleisters und des Coininhabers nicht nachverfolgen. 

Die für das Verfahren nötigen Rechenschritte sind im Folgenden beschrieben. Angenommen der Unterzeichnende verfügt über eine private Signierfunktion $s'$ und eine öffentliche Funktion $s$, sodass $s(s'(x)) = x$. Der Nutzer verfügt über die privaten Funktionen $c$ und dessen invers $c'$, sodass $c'(s'(c(x))) = s'(x)$. 
\begin{enumerate}
    \item Der Nutzer beginnt nun damit, sich ein $x$ auszusuchen. Dieses wird durch zufällige Redundanz vor Kollisionen geschützt und mit $c(x)$ unkenntlich gemacht.
    \item Anschließend erhält der Unterzeichnende $c(x)$, berechnet $s'(c(x))$ und schickt den entsprechenden Wert an den Nutzer zurück.
    \item Wenn der Nutzer nun $c'(s'(c(x))) = s'(x)$ berechnet, so erhält er den signierten Ursprungswert $x$ ohne, dass der Unterzeichnende $x$ je kannte.
\end{enumerate}
Daraufhin kann jede weitere Person die Unterschrift überprüfen, indem diese die öffentliche Funktion $s$ verwenden um $s(s'(x))$ zu berechnen und das Ergebnis mit $x$ abgleichen. 

Blinde Signaturen sind bei dem Ansatz von privatsphäreschützenden Zahlungs- und Reputationssystemen einer der Kernbausteine der verwendet wird, um einen vertrauenswürdigen Austausch zwischen den Parteien zu ermöglichen. Sie liefern die Grundlage der Kommunikation.

\section{Partiell Blinde Signaturen}
\label{sec:partBlindSig}
\begin{figure}[h]
    \label{fig:partBlindSig}
    \centering
    \includegraphics*[width=1\textwidth]{partBlindSig.png}
    \caption{Ablauf einer partiell blinden Signatur \cite{abe2000provably}}
\end{figure}
Partiell blinde Signaturen ähneln sich vom Effekt stark zu blinden Signaturen von Chaum aus \ref{sec:blindSig}. Der jedoch entscheidende Unterschied ist, dass es bei partiell blinden Signaturen einen Infowert gibt, der sowohl dem Nutzer als auch dem Signierendem bekannt ist. Dieser kann genutzt werden, damit der Signierende möglicherweise Prüfungen durchführen kann und zu entscheiden, ob er die Nachricht wirklich signieren möchte. Diese Eigenschaft wird im späteren Verlauf beispielsweise dazu verwendet einen Coin partiell blind zu signieren. Hierbei ist es essenziell, dass der Signierende den monetären Wert des Coins prüfen kann, da ein Nutzer sonst freie Kontrolle über den Wert seines eigenen Coins hat. Mit partiell blinden Signaturen kann genau dies gewährleistet werden. Dabei ist der monetäre Wert des Coins die Info und der kryptographische Wert des Coins die Nachricht. Nun kann der Signierende prüfen, ob der monetäre Wert der vereinbarte Wert ist und kann den kryptographischen Wert des Coins blind signieren. Der springende Punkt ist der Zusammenhang zwischen Info und Nachricht, da sonst der monetäre Wert des Coins nach dem Signieren durch den Nutzer verändert werden könnte. Um dies zu verhindern, verwendet das Verfahren den Hash der Info als Teil der Signatur, so dass diese nur gültig ist, solange die Info unverändert bleibt.

\subsection{Funktionweise}
Die Durchführung einer partiell blinden Signatur besteht aus 4 Schritten. Diese 4 Schritte sind notwendig, um die Abhängigkeit von dem msg und Info herzustellen. Es wird davon ausgegangen, dass vor dem ersten Schritt beide Parteien über den Infowert verfügen. Der Signierende bildet zuerst den Hashwert der Info, signiert diesen und schickt ihn an den Nutzer. Dieser bildet den gleichen Hashwert der Info und verwendet die erhaltenen Werte zusammen mit einer Reihe an Zufallszahlen, um $\alpha$ und $\beta$ zu berechnen. $\epsilon$ ist der darauffolgende Hash von $\alpha,\beta,z$ und $msg$. Hier fließt die bereits signierte Info über $\alpha$ und $\beta$ mit ein. Kurz darauf empfängt der Signierende $e$, welches nun sowohl Info als auch msg beinhaltet. Dieses $e$ kann er nun verwenden, um Info und msg zu signieren und die aus den Berechnungen resultierende Werte an den Nutzer zu senden. Der Nutzer kann dadurch $\rho,\omega,\sigma,\delta$ bestimmen und speichern. Möchte der Nutzer zu einem beliebigen Zeitpunkt die Signatur auf ihre Gültigkeit prüfen, so kann er $\omega + \delta$ mit  $H (g^\rho y^\omega || g^\sigma z^\delta || z || msg)$ vergleichen. Wenn die Werte übereinstimmen, ist die Signatur valide.

Durch die Verwendung von Info als Teil der Signatur ist gewährleistet, dass die Signatur nur bei einer unveränderten Info und msg valide bleibt. Denn sollte sich die Info oder msg ändern, dann würde die Rechnung zur Überprüfung einen anderen Hash erzeugen, welcher nicht mehr mit $\omega+\delta$ übereinstimmt. Insgesamt ist das partiell blinde Signaturen Schema etwas umständlicher als Chaums blinde Signaturen. Dennoch bietet es die Möglichkeit einen öffentlichen Wert zu kommunizieren und dessen nachträgliche Änderung zu verhindern.


\section{Elliptische Kurven Kryptographie}
\label{sec:ecc}
Die Kryptographie über elliptische Kurven (ECC - elliptic curve cryptography) ist ein Zweig der Kryptographie, der bereits seit 1985 besteht \cite{ecc-miller1985use} und trotz dessen nur wenig Aufmerksamkeit genießt. Hierbei geht es um das Ver- und Entschlüsseln von Nachrichten anhand von Punkten auf einem elliptischen Graph, was verglichen mit RSA, das auf der Faktorisierung großer Zahlen basiert, erhebliche Performanzsteigerung liefert.

\subsection{Trapdoor functions}
Das asymmetrische RSA Verschlüsselungsverfahren ist heute weltbekannt und wird in über 90\% der Onlinekommunikation verwendet \cite{ecc-rsa_amount}. Dessen Sicherheit basiert genauso wie die von ECC auf sog.  \textit{Trapdoor functions}. Ein Trapdoor function ist ein mathematisches Problem, welches in eine Richtung leicht zu berechnen ist, das Inverse jedoch erheblich schwerer zu bestimmen ist. Im Falle von RSA ist die Trapdoor function das Faktorisierungsproblem. Es ist leicht 2 sehr große Zahlen miteinander zu multiplizieren. Allerdings ist es deutlich schwerer bei einem gegebenen Produkt dessen Faktoren zu bestimmen, insbesondere wenn die Faktoren jeweils Primzahlen sind. Dies ist der Grund, weshalb RSA sicher ist und zuverlässig die Kommunikation schützt. Bei ECC ist die Trapdoor function, die die Sicherheit der Verschlüsselung ausmacht, eine andere. Jedoch kann anhand dieser genauso ein Public und Private-Key generiert werden.
\subsection{Funktionsweise}
Um die Trapdoor function hinter ECC zu verstehen, müssen wir uns zuerst elliptische Kurven anschauen. Die algebraische Struktur von elliptische Kurven ist eine Gruppe, welche aus einer Menge von Punkten $M$ und einer binären Operationen $\circ$ auf 2 Punkten der Menge besteht. Die Definition einer Gruppe fordert, dass die Elemente die Eigenschaften der Assoziativität, Identität, Existenz eines inversen Elements und je nach Quelle auch Abgeschlossenheit erfüllen. \cite{ecc-aradi2016einfuhrung}\cite{ecc-bogopolskij2008introduction} Zudem müssen die Koordinaten aller Punkte $(x,y) \in M$ die in der Menge liegen, aus dem endlichen Feld stammen, sowie die Gleichung:

\begin{equation}
    \label{ecc-equation}
    y^2 = x^3+ax+b
\end{equation} erfüllen. Zusammen bildet die Menge an Punkten $M$ einen Graph, der je nach Wahl der Parameter $a,b$ einer Form aus Abbildung \ref{fig:ecc_1} ähnelt. Aufgrund der Gleichung \ref{ecc-equation} entsteht der Zusammenhang, dass eine Gerade durch zwei zufällig gewählte Punkte $P,Q \in M$, den Graph immer an genau einer dritten Stelle schneidet. Zusätzlich ist der Graph an der X-Achse durch das $y^2$ gespiegelt. Mit diesen Eigenschaften kann nun die Operation $\circ$ definiert werden.\\
Diese arbeitet wie folgt: Bei Eingabe von $A,B \in M$ finde den invertierten dritten Schnittpunkt mit dem Graph. Dieser sei hier mit $C$ beschrieben. Eine Ausführung von $A \circ B = C$ ist in Abbildung \ref{fig:ecc_2} verdeutlicht.

\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{ecc_1.png}
    \caption{Mögliche Form einer elliptischen Kurve \cite{ecc-cloud2013elliptic}}
    \label{fig:ecc_1}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{ecc_2.png}
    \caption{Operation $\circ$ auf Punkten $A,B \in M$ \cite{ecc-cloud2013elliptic}}
    \label{fig:ecc_2}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{ecc_3.png}
    \caption{Graph nach Anwendung von $\mathbb{Z}_p$ \cite{ecc-cloud2013elliptic}}
    \label{fig:ecc_3}
\end{figure}

Die Operation $\circ$ kann beliebig oft hintereinander mit dem jeweils neu entstehenden Punkt ausgeführt werden. Genau hier liegt die Trapdoor function von ECC. Mit Kenntnissen über der Startpunkt $A$ und die Anzahl der Ausführungen $n$, ist es einfach den Endpunkt $E$ zu berechnen. Wenn allerdings nur der Endpunkt $E$ und Startpunkt $A$ gegeben sind, ist es sehr rechenaufwändig die Anzahl an Ausführungen zu bestimmen.

\subsection{Anwendung in der Kryptographie}
Allgemein ist zu beachten, dass elliptische Kurven, die für ein kryptographischen Verwendung in Frage kommen, eine andere Form haben als die eben aufgeführt Abbildungen (\ref{fig:ecc_1},\ref{fig:ecc_2}). Entscheidend ist hierfür die Wahl des endlichen Feldes. In der Kryptographie wird hier meist $\mathbb{Z}_p$ verwendet. Diese Wahl bringt 2 Eigenschaften mit sich:
\begin{enumerate}
    \item Das $p$ in $\mathbb{Z}_p$ besagt, dass alle Werte $x \in \mathbb{Z}_p$, $0 \leq x \leq p-1$ erfüllen müssen. Durch die Wahl dieses Wertebereichs, können die X und Y-Achse nie den Wert $p$ überschreiten, sondern beginnt anstatt wieder bei 0.
    \item Die zweite Eigenschaft ist die ausschließliche Betrachtung ganzer Zahlen als X und Y-Koordinate. Hierdurch wird aus dem Graphen eine Menge an zufällig aussehend gewählten Punkten. Der Graph für die kryptographische Verwendung einer elliptischen Kurve ist ein Abbildung \ref{fig:ecc_3} visualisiert.
\end{enumerate}
Nun muss ein passendes $p$ sowie $a,b$ bestimmt werden, um die genaue Menge an Punkten zu spezifizieren. Hierfür gibt es bereits eine große Auswahl und Werten in der Literatur \cite{ecc-lochter2010elliptic}\cite{ecc-merkle2013elliptic}. Eine der prominentesten ist die ``Curve25519`` von Daniel J.Bernstein \cite{ecc-bernstein2006curve25519}. Sie hat den Werte $p=2^{255}-19$ (daher der Name) und die elliptische Funktion $y^2=x^3+486662x^2+x$.


\subsection{Vor- und Nachteile}
Allgemein betrachtet ist die Tatsache, dass ECC eine schnellere Berechnungszeit liefert als RSA nicht von der Hand zu weisen \cite{ecc-cloud2013elliptic}. Da sich die Laufzeiten von Verschlüsselung und Entschlüsselung durch RSA und ECC asymptotisch nicht gleich verhalten, ist es schwer eine endgültige Antwort zu nennen. Allerdings schlägt ECC RSA bei der Gesamtzeit für Ver- und Entschlüsselung je nach Nachrichtengröße um einen Faktor von \textasciitilde $3-20$ \cite{ecc-mahto2018performance}\cite{ecc-bao2022research}. Zudem eignet sich ECC vor allem als Ver- und Entschlüsselungsmethode auf rechenschwachen Geräten wie Mobiltelefonen aufgrund von kleineren Schlüsselgrößen\footnote{Um eine Security Bit Level von 256 Bits mit RSA zu erreichen, ist eine Schlüssellänge von 15360 Bits nötig, während es bei ECC lediglich 512bits sind.\cite{ecc-mahto2018performance}}. So können Rechenaufwand, Energieverbrauch und RAM-Auslastung gesenkt werden \cite{ecc-gupta2011ecc}.

Allerdings wurde 2007 bekannt, dass der Pseudo Random Number Generator (PRNG) Dual\_EC\_DRBG eine potenzielle Backdoor hat, die es Nutzern mit Informationen über einen bestimmen Wert die Zufälligkeit problemlos knacken lies \cite{ecc-green2013backdoor}. Dual\_EC\_DRBG wurde 2005-2006 zusammen von NIST (National Institute of Standarts and Technology) und der NSA veröffentlicht und basiert die Auswahl der zurück gegebenen pseudozufälligen Zahlen auf Berechnung über elliptischen Kurven. Dieser Vorfall schwächt bis heute das generelle Vertrauen in ECC. \cite{ecc-cloud2013elliptic}

\section{AES - Advanced Encryption Standard}
\label{sec:aes}
Der Advanced Encryption Standard ist einer der weltweit am häufigsten verwendeten symmetrischen Verschlüsselungsalgorithmen. AES wurde 2001 vom NIST als offizieller Standard für die Verschlüsselung von Daten festgelegt und hat den früher verwendeten Data Encryption Standard (DES) ersetzt, da dieser als unsicher galt. AES basiert auf dem Rijndael-Algorithmus, der von den Kryptographen Joan Daemen und Vincent Rijmen entwickelt wurde. Die hohe Sicherheit, Effizienz und Flexibilität von AES haben dazu beigetragen, dass er heute in einer Vielzahl von Anwendungen, von vertraulichen Regierungsdokumenten bis hin zur Verschlüsselung von Festplatten und Netzwerkverkehr, zum Einsatz kommt.

AES ist ein blockbasierter Verschlüsselungsalgorithmus, der Daten in Blöcken von 128 Bit verarbeitet. Dabei verwendet AES symmetrische Schlüssel, was bedeutet, dass derselbe Schlüssel sowohl für die Verschlüsselung als auch für die Entschlüsselung der Daten verwendet wird. Der Algorithmus unterstützt Schlüsselgrößen von 128, 192 und 256 Bit, wobei größere Schlüssel im Allgemeinen eine höhere Sicherheit bieten, jedoch auch höhere Rechenressourcen erfordern. AES durchläuft mehrere Runden von Transformationen, die die Klartextdaten in scheinbar zufällige Chiffretextdaten umwandeln. Bei der 128-Bit-Schlüsselgröße umfasst der Algorithmus 10 Runden, bei 192-Bit sind es 12 Runden und bei 256-Bit werden 14 Runden verwendet. Jede dieser Runden besteht aus mehreren Schritten, darunter Substitution (Byte Substitution mittels S-Box), Zeilenverschiebung (ShiftRows), Spaltenmischung (MixColumns) und die Hinzufügung eines Rundenschlüssels (AddRoundKey).

Das zentrale Sicherheitsmerkmal von AES ist seine Widerstandsfähigkeit gegen bekannte Kryptoangriffe wie Differenzial- und Linearkryptanalyse. Dies wird durch eine starke Schlüsselabhängigkeit und die Nutzung mehrerer kryptographischer Prinzipien, wie der Substitutions-Permutations-Netzwerkstruktur (SPN), erreicht. Darüber hinaus spielt die sogenannte Avalanche-Eigenschaft eine entscheidende Rolle: Eine kleine Änderung im Klartext oder im Schlüssel führt zu drastischen Änderungen im Chiffretext, wodurch es Angreifern erschwert wird, Rückschlüsse auf den ursprünglichen Klartext oder den verwendeten Schlüssel zu ziehen.\\

Verglichen mit asymmetrischen Verschlüsselungsverfahren fehlen AES jedoch gewisse Schutzziele die über die letzten Jahre zunehmend an Wichtigkeit gewonnen haben. Die Verwendung von einem einzelnen Schlüssel führt dazu, dass es die Integrität einer Nachricht nicht gezeigt werden kann, was bedeutet, dass Veränderungen an der Nachricht, die nicht vom ursprünglichen Sender stammen nicht festgestellt werden können. Aus diesem Grund haben Sadi Arman, Shamim Al Mamun und Nuray Jannat einen modified AES Algorithmus (MAES) veröffentlicht, der durch die Verwendung weitere Bit Verschiebeoperationen eine Senderauthentifizierung, Empfängerauthentifizierung und Nachrichtenintegrität gewährleisten kann \cite{aes-arman2024modified}. Der Algorithmus beschränkt die für AES üblichen Schlüssellängenauswahl von 128, 192 und 256-bit Schlüsseln auf ausschließlich 128-bit Schlüssel, erhöht dafür aber gleichzeitig die Datenübertragungsrate um bis zu 20\% \cite{aes-arman2024modified}.

\section{Abschluss}
%pro und contra von allen
Aus dieser Liste an verwandten Arbeiten geht hervor, dass es noch kein Bezahlsystem gibt, das den in \ref{chap:req} aufgestellten Anforderungen gerecht wird. Die Tabelle \ref{tab:nichtfunktionale_Anforderungen} gibt dabei einen Überblick über die vorgeschlagenen Lösungsansätze und welche der Anforderungen durch sie nicht erreicht werden.
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        & GNU Taler & Bitcoin & Ethereum & Privacy Pass \\
        \hline
        Anonymität & $\times$  & \texttildelow & \texttildelow & $\checkmark$ \\
        \hline
        Unverkettbarkeit & $\times$  & \texttildelow & \texttildelow & $\checkmark$ \\
        \hline
        Zeitsensitivität & $\checkmark$ & $\times$ & $\times$ & $\checkmark$ \\
        \hline
        Skalierbarkeit & $\checkmark$ & \texttildelow & $\checkmark$  & $\checkmark$\\
        \hline
        Vertraulichkeit & $\checkmark$ & $\checkmark$ & $\checkmark$ & \texttildelow \\
        \hline
        Integrität & $\checkmark$ & $\checkmark$ & $\checkmark$ & \texttildelow \\
        \hline
    \end{tabular}
    \caption{Erfüllung nichtfunktionaler Anforderungen}
    \label{tab:nichtfunktionale_Anforderungen}
\end{table}
GNU Taler erfüllt jede der Anforderungen - abgesehen von der Anonymität. Zwar schützt GNU Taler die Anonymität des Käufers und hält dessen Privatsphäre aufrecht, allerdings sollte ein im Datentreuhändermodell verwendetes Bezahlsystem hauptsächlich die Privatsphäre des Verkäufers schützen, die von GNU Taler gezielt öffentlich gemacht wird.

Bitcoin und Ethereum teilen sich aufgrund der Verwendung einer Blockchain das Problem von nicht zeitsensitiven Transaktionsdauern. Mit einer geschätzten Wartezeit von einer Stunde bzw. 6 Minuten, bis eine Transaktion mit ausreichend Sicherheit bestätigt werden kann, ist die Verwendung der beiden Technologien unter Einhaltung der Anforderungen nicht möglich. Des Weiteren kann argumentiert werden, dass durch den Public Ledger, der alle Transaktionen pseudonymisiert veröffentlicht, die Anonymität nur in Teilen gewahrt werden kann. 

Vertraulichkeit und Integrität werden durch Privacy Pass nicht nativ unterstützt. Da das Protokoll ausschließlich für das Umgehen von CAPTCHAs bei CDNs entwickelt wurde, ist von einer https-Verbindung auszugehen, die diese Schutzziele gewährleistet. Jedoch sieht Privacy Pass selbst keine Maßnahmen zum Schutz der Kommunikation vor.\\

Aufgrund dessen, dass keines der zuvor genannten Bezahlsysteme sämtliche Anforderungen erfüllt, muss für den Anwendungsfall im Datentreuhändermodell ein neues Bezahlsystem entworfen werden. Dieses Bezahlsystem wird in dem folgenden Kapitel genauer beschrieben und spezifiziert. 


%==================================================================================================



\chapter{Systementwurf}
\label{chap:systems}
%reputation, grober ablauf, auf welchem rl basiert, präziser ablauf in der Schrittbeschreibung

In diesem Kapitel werden die neu erarbeiteten Systeme genau beschrieben. Dafür werden zu Beginn einige Designentscheidungen und Ziele des Systems genannt. Anschließend wird für jedes der drei Systeme ein detailierter Ablauf beschrieben und weitere wichtige Informationen für die Funktionsweise der Systeme genannt.

\section{Ziel}
\label{sec:mainPart_ziel}
Um einen privatsphäreschützenden Anreiz für die Benutzung eines Datentreuhänders zu schaffen wird im Folgenden ein Bezahlsystem vorgestellt. Dieses Bezahlsystem erlaubt es den Datengebenden für ihre Daten im Gegenzug einen finanziellen Ausgleich zu verlangen, ohne dabei persönliche Informationen preisgeben zu müssen. Weder der Datennutzende noch der Datentreuhänder kann bei einer regulären Transaktion bestimmen, welcher Datengebende eine Bezahlung erhält. Der hierfür verwendete Ablauf sieht vor, dass ein Datengebender zuerst seine Daten an den Datennutzenden überträgt und ihm etwas Zeit zur Verwertung der Daten lässt. Ein Datennutzender erhält maximal 12 Stunden Zeit, um den Zahlvorgang abzuschließen. Schafft er dies nicht innerhalb der 12 Stunden, so kann der Datentreuhänder ihn von der weiteren Verwendung der Plattform ausschließen. 

Damit der Datengebende seine Anonymität nicht ausnutzen kann, gibt es 2 Mechanismen zur Betrugserkennung. Der erste ist eine Offenlegung der Kommunikation im Streitfall. Sollte sich eine der beiden Parteien betrogen fühlen, so kann sie vom Datentreuhänder eine Schlichtung verlangen. Dafür werden die für die Kommunikation verwendeten Einmalschlüssel dem Datentreuhänder mitgeteilt, sodass dieser alle Schritte nachvollziehen kann und entscheiden kann, ob ein Betrug vorliegt oder nicht. 
Der zweite Mechanismus ist eine Reputationsvergabe. Wenn ein Datengebender besonders qualitativ gute Daten liefert, kann ein Datennutzender ein gute Bewertung für ihn ausstellen, was seine Reputation verbessert. Wenn er hingegen besonders schlechte Daten liefert, so kann ein Datennutzender sich weigern ihn zu bezahlen, was die Reputation herunterzieht. Des Weiteren kann bei jedem Aufruf nach Daten von einem Datennutzenden ein Reputationsschwellwert festgelegt werden, um Datengebende mit zu schlechter Reputation von dem Einreichen ihrer Daten abzuhalten. 

\section{Geld als Anreiz}
Da im Datentreuhandmodell ein Datennutzender meist durch ein Unternehmen oder eine Forschungseinrichtung repräsentiert wird, ist es vorstellbar, dass der Datennutzende selbst eine Dienstleistung anbieten oder in Aussicht stellen kann. Hier wurde aber Geld als Anreiz gewählt, da die Verwendung solcher Dienstleistungen als Anreiz einige Nachteile mit sich ziehen kann.

\begin{enumerate}
    \item \textbf{Universal.} Kein Handelsgut oder Dienstleistung ist so universelles begehrt wie Geld. Zwar ist es möglich, dass ein Business, welches hier als Datennutzender auftritt, für die Preisgabe der Daten eine Dienstleistung anbietet. beispielsweise können Social Media Plattformen wie X kostenlose zeitlich bedingte Premiumabonnenments oder vergleichbar Angebote in Aussicht stellen. Jedoch ist das Interesse an solchen Angeboten subjektiv, was sie als mögliche Anreize zwar denkbar aber eher suboptimal macht.
    \item \textbf{Einheitlich.} Wenn der Anreiz durch den Datennutzenden gestellt wird, wird dieser in jedem einzelnen Fall unterschiedlich sein. Aus der Kommunikationsstruktur folgt, dass alle unterschiedlichen Kompensationen auf irgendeinem Weg über den Datentreuhänder laufen müssen. Daraus ergibt sich ein enormer zusätzlicher Aufwand an Entwicklung und Implementation für jeden Datennutzenden.
    \item \textbf{Verfügbarkeit.} Manche Datennutzende, wie beispielsweise Forschungsinstitutionen, haben nur eine eingeschränkte Auswahl an Dienstleistungen oder Produkte die sie Datengebenden anbieten können. Da sie hauptsächlich an der Forschung interessiert sind, verfügen sie über erheblich weniger Konsum- oder Unterhaltungsprodukte verglichen mit anderen Firmen. Geld ist hingegen deutlich leichter zugänglich.
    \item \textbf{Wahrung der Anonymität.} Viele C2B Treuhänder legen Wert auf die Anonymität oder Pseudonymität der Datengeber. Diese kann jedoch dadurch, dass ein Datennutzender die versprochene Dienstleistung kontrolliert, verloren gehen. Es ist beispielsweise denkbar, dass ein Datennutzender einen vielversprechenden Anreiz verspricht, diesen aber hinter einer Registrierung und Angaben von persönlichen Daten verbirgt, so dass die durch den Treuhänder etablierte Anonymität umgangen wird.
    \item \textbf{Einhalt der Leistung.} Der Datentreuhänder kann bei der Auslagerung von Anreizen an den Datennutzenden nicht zuverlässig kontrollieren, dass der Datennutzende die versprochene Dienstleistung wirklich einhält.
\end{enumerate}
Durch die Verwendung von Geld als Anreiz werden diese Punkte umgangen. Das Interesse der Datengebenden ist nun ausschließlich abhängig von dem Ruf und dem persönlichen Interesse an einem Datengebenden und nicht von dessen Anreizangebot. Der Anspruch auf den versprochenen Anreiz ist für jeden Datennutzenden gleich implementiert und hängt maximal von der Wahl anderer Parameter ab. Es kann davon ausgegangen werden, dass alle Datennutzenden über Geld verfügen und dieses als Kompensation verwenden können. Aufgrund des Stellenwertes von Geld in unserer Gesellschaft sind bereits viele Wegen entwickelt worden, wie dessen Wert anonym oder pseudonym an andere übertragen werden kann. Der Datentreuhänder hat die volle Kontrolle darüber, dass ein zu zahlender Geldbetrag vom Datennutzenden abgegeben wird und auch bei Datengebenden ankommt.

\section{Annahmen über das Datentreuhändermodell}
Datentreuhänder können in verschiedenen Variation eingesetzt werden. Abschnitt \ref{sec:dt} gibt darüber bereits einen Überblick. Hier werden Annahmen getroffen, die das Datentreuhändmodell betrefen, für welches das Anreizsystem entworfen wird. Dadurch soll verdeutlicht werden, in welchem Datentreuhändermodell das System am besten eingesetzt werden kann.

Zuerst sei anzunehmen, dass es sich bei dem Datentreuhänder um einen freiwilligen Customer to Business Treuhänder handelt. Dies ist dadurch begründet, dass bei verpflichtenden Datentreuhändern die Benutzung vorgeschrieben ist und ein Anreiz zur Benutzung des System die Nutzerzahlen nicht beeinflusst. Weiter haben bei Business to Business Treuhändern beide Parteien einen Profit aus dem Tausch der Daten. Beide sind gleichzeitig am Daten empfangen und am Daten versenden. Hier fällt daher eine deutliche Einteilung in Datengebende, die Anreize erhalten und Datennutzende, die Anreize bieten, schwer. Zusätzlich ist die Aussicht auf Datengewinn durch einen Tausch häufig Anreiz genug, um ein Unternehmen zur Verwendung eines B2B Datentreuhänders zu bewegen. \todo{proof}

Die beim Datentreuhänder abgelegten Daten sind verschlüsselt. Der Datentreuhänder speichert lediglich eine lange Liste an Bytes, kann aber anhand der verschlüsselten Bytes nicht feststellen, was die Daten beinhalten, welche Daten von welchem Datengebenden stammen oder wo ein Datensatz aufhört und der nächste beginnt. Er weiß also nichts über die bei ihm abgelegten Daten. Damit ein Datengebender trotzdem den Zugang zu seinen Daten behält, werden ihm beim Hochladen seiner Daten, Werte für den kontreten Ablageort seiner Daten, sowie einen passenden Schlüssel zur Entschlüsselung mitgeteilt. Wenn er seine abgelegten Daten nun einsehen möchte, kann er den Satz an Bytes von dem Speicherort anfragen und den erhaltenen Geheimtext mit Hilfe des Schlüssels entschlüsseln, was seine ursprünglich hochgeladenen Daten zum Vorschein bringt.

Es gibt 2 Paradigmen bezüglich der Auswahl von Datengebenden. Das erste davon umfasst den Sachverhalt, dass ein Datengebender dem Datentreuhänder erklärt, dass er seine Daten zum Verkauf anbieten möchte. Der Datentreuhänder bewirbt darauf die Daten des Datengebenden auf einer - einem Marktplatz vergleichbaren Plattform - und Datennutzende wählen sich die Datengebende ihre Wahl aus und beziehen von ihnen die angeboten Daten. Das zweite Paradigma dreht die Zuständigkeit um. Hier kann ein Datennutzender einen Aufruf starten, der Datengebende dazu aufruft, Daten eines bestimmen Typen zu verkaufen. Jetzt können sich Datengebende durch eine Liste an Aufrufen durcharbeiten und den Richtig für sich heraussuchen. Sobald ein passender Aufruf entdeckt wurde, kann ein Datensatz des vom Datennutzenden angefragen Datentyps vorgelegt werden. 
Im Folgenden wird vom zweiten Paradigma ausgegangen, da es sowohl Rechenaufwand- als auch Privatsphärenvorteile liefert. Das Erstellen eines Aufrufs sowie das Weiterleiten zum Datentreuhänder sollte beides in $O(1)$ geschehen. Dadurch hängt die Laufzeit von der konkreten Implementierung ab, allerdings beinhaltet das Erstellen eines Aufrufs nur die Zusammensammlung von Informationen wie Datentypen, Namen oder Beschreibung. Es sind in meisten Fällen keine iterativen Vorgänge aktiv, die die Laufzeit in $O(n)$ bringen könnte. Im Anschluss sind keine weiteren Berechnungen von Nöten um Daten zu empfangen. Bei der individuellen Auswahl von Datengebenden und der Nachfrage nach deren Daten entsteht hingegen ein Zusammenhang zwischen der Anzahl an Datensätzen und des Rechenaufwands des Datennutzenden. Da der Datennutzende für jeden Datengebenden eine Bewertung erzeugen muss, die darüber entscheidet ob die Daten erworben werden oder nicht, ergibt sich für den Erhalt von $n$ Datensätzen ein Rechenaufwand von $O(n)$. Die Minimierung des Rechenaufwands für den Datennutzenden ist vor allem interessant, da Datennutzende durch Unternehmen repräsentiert werden, die in Extremfällen mehrere tausend Anfragen pro Sekunden bearbeiten müssen, während Datengebende an ihren Endgerät einen deutlich überschaubareren Rechenaufwand leisten müssen.
Privatsphärenvorteile werden durch das zweite Paradigma ebenfalls erbracht, da die Einreichung von Daten so vollständig anonym ablaufen kann. Solange durch die Kommunikation zur Mitteilung des Speicherorts und Datenschlüssels keine Informationen preisgegeben werden, kann der Datennutzende den Datengebenden unmöglich deanonymisieren. Die von ihm erhaltenen Datenparameter können dazu benutzt werden, Daten beim Datentreuhänder zu erfragen. Dieser weiß genauso wenig, wessen Daten angefragt wurden. Im ersten Paradigma hingegen müssen mindestens die Informationen, die ein Datennutzender braucht um eine aussagekräftige Einschätzung über die Daten trefen zu können, bereitgestellt werden. Je nach dem welche Informationen davon betroffen sind, besteht eine Möglichkeit, die Angebote eines Datengebenden miteinander zu verlinken und so Informationen über ihn zu gewinnen.

 

\section{Generelles}
%PKI für schlüssel assumen
Im Gegensatz zu GNU Taler soll das Bezahlsystem hauptsächlich den Datengebenden und dessen Informationen schützen. Die Privatsphäre des Datennutzenden ist zwar ebenfalls schützenswert aber eher von geringerer Bedeutung, da im Datentreuhändermodell der Datennutzende meist durch ein Unternehmen oder eine Forschungseinrichtung dargestellt wird. Hinzu kommt die Struktur eines Datentreuhänders, die den Datennutzenden dazu veranlasst, eine Menge an Informationen anzugeben, um vom Datentreuhänder zugelassen zu werden. Der Datengebende hingegen ist eine einzelne Privatperson, die ihre gesammelten Daten bewusst an Unternehmen oder Forschungseinrichtungen verkaufen möchte. Der Schutz der Privatperson ist hier daher von größerem Interesse. 

Unter diesen Umständen ist eine herkömmliche Überweisung per Bank deutlich zu unsicher. Sie benötigt Information wie die IBAN des belasteten Kontos und die IBAN des empfangenden Kontos, um zu wissen, von wo nach wo eine Geldsumme fließen soll. Dadurch werden bereits zu viele Informationen über den Datengebenden bekannt, da der Datennutzende nun genau herausfinden kann, von wem die erworbenen Daten stammen und ob er bereits vorher schon von demselben Datengebenden Daten gekauft hat. Zusätzlich kann die Bank nachvollziehen, dass eine Privatperson sich als Datengebender angemeldet hat und wem sie ihre Daten bereits verkauft hat.
Um dieses Problem zu lösen, wird hier eine der gängigsten anonymen Onlinezahlmethoden verwendet: Kryptowährungen. Die Abschnitte \ref{subsec:gnu}, \ref{sec:bitcoin}, \ref{sec:ethereum}, \ref{sec:privacy-pass} führen bereits einige davon auf und beschreiben, warum diese nicht im Datentreuhändermodell verwendbar sind. Aufgrund dessen wird hier eine neues System eingeführt. Jedoch ist dessen Coins weder Blockchain basiert noch für Spekulationszwecke brauchbar. Ein Coin kann - so wie bei vielen Kryptowährungen üblich - ausschließlich bei einem Exchange gegen Geld getauscht werden. Bei dem initialen Tauschen mehrerer Coins ist der monetäre Wert in Euro fest im Coin gespeichert und kann nicht verändert werden. 

An dieser Stelle ist anzumerken, dass keine Regulierungen oder Identifizierung zum Erwerben eines Coins benötigt werden. Jedoch sind Datennutzende die einzigen, die Coins sicher ausgeben können. Das wird dadurch deutlich, dass das Bezahlsystem nur dazu verwendet werden kann, Coins von Datennutzenden zu Datengebenden zu übertragen. Datengebende können zwar selbst auch Coins erwerben, allerdings ist der Handel nicht über das hier eingeführte Bezahlsystem möglich. Daher bleibt nur der reguläre Tausch, welcher außerhalb des Systems stattfindet und keine Betrugserkennung besitzt. Unter der Berücksichtigung dessen, dass das Einzige was dem Coin einen festen Wert sicherstellt die Signatur des Exchanges ist, kann leicht ein nicht verifizierter Coin erstellt werden und im unsicheren Tausch angeboten werden. Der andere Tauschpartner hat keine Möglichkeit den Coin vor Abwicklung des Tauschs auf seine Echtheit zu prüfen, was ein großes Potentiall für Betrug bietet. Aufgrund dessen ist anzunehmen, dass nur Datennutzende Coins erwerben werden, da der Tausch unter Datengebenden deutlich zu unsicher ist.

Nachdem ein Datennutzender einen Coin erworben hat, kann er diesen lokal so lange speichern, bis er ihn ausgeben möchte. Sobald ihm ein Datengebender seine Daten mitteilt, hat der Datennutzende 12 Stunden Zeit die Daten auszuwerten. Wenn ein Datennutzender nach Ablauf der 12 Stunden noch keine Transaktion zu dem Datengebenden abgeschlossen hat und dieser bei dem Datentreuhänder eine Betrugsanklage gegen den Datennutzenden vorlegt, so kann der Datentreuhänder sich dazu entschließen den Datennutzenden entweder zeitlich bedingt oder dauerhaft von der weiteren Verwendung der Plattform auszuschließen. Ein gutwilliger Datennutzender kann nach der Auswertung der Daten eine passende Summe an Coins aus seinem lokalen Speicher auslesen und an den Datengebenden senden. Sobald dieser die Coins empfängt prüft er die Signatur der Coins. Wenn die Signatur mit der des Exchanges übereinstimmt, kann er sie an den Exchange weiterleiten um sich den monetären Wert beispielsweise auf sein Konto gut schreiben zu lassen. Stimmt die Signatur nicht mit der des Exchanges überein, so kann der Datengebende auch hier wieder einen Betrug beim Datentreuhänder melden.

\section{Verschlüsselung}
Da in der Kommunikation indirekt Geld transferiert wird, ist es von höchster Priorität, die gesendeten Nachrichten vor dem Mithören oder Verändern durch unbefugte Dritte zu schützen. Für diesen Schutz wird eine Mischung aus der in Abschnitt \ref{sec:ecc} erklärten elliptischen Kurven Kryptographie und dem in Abschnitt \ref{sec:aes} angeführten MAES-Algorithmus verwendet. 

Mit der Benutzung eines Public-Keys bei ECC wird sichergestellt, dass nur Personen mit Wissen über den zugehörigen Private-Key die Nachricht lesen können. Anschließend wird ein Hash der verschlüsselten Nachricht gebildet und mit dem Private-Key des Senders signiert. Auf diesem Weg kann der Empfänger die Nachricht selbst den Hash bilden und prüfen, ob der signierte Hash mit dem selbst gebildeten übereinstimmt. Dadurch kann sowohl die Vertraulichkeit als auch die Integrität der Nachricht sichergestellt werden.

AES hingegen verwendet nur einen Schlüssel, der gleichzeitig zum Verschlüsseln und Entschlüsseln einer Nachricht gebraucht wird. Es erreicht erheblich schnellere Berechnungszeiten als ECC, da AES auf Operationen basiert, die lediglich bit verschieben, aber keine komplexen mathematischen Berechnungen durchführen. Da AES aber keine Integrität gewährleisten kann, wird hier für die symmetrische Kommunikationsverschlüsselung der MAES-Algorithmus verwendet. Durch ihn kann - wie bei ECC - eine unbemerkte Veränderung der Nachricht ausgeschlossen werden, während trotzdem nur ein Schlüssel zum Ver- und entschlüsseln benötigt wird.\\

Es sei angemerkt, dass von hieran folgend jede Nachrichtenübertragung zwischen 2 Akteuren - dies mögen beispielsweise Datentreuhänder und Datengebender sein - immer via ECC verschlüsselt und signiert wird, es sei denn es wird für den Kommunikationsschritt anders definiert.

\section{Notationserklärung}
In den Systementwürfen werden alle Kommunikationsschritte mit ihren übertragenen Informationen beschrieben. Für die konkrete Angabe der übertragenen Informationen wird die folgende Notation verwendet.
\begin{itemize}
    \item Datengebende sind mit $DG$, Datennutzende mit $DN$ und Datentreuhänder mit $DT$ abgekürzt.
    \item $pk$ steht für Public-Key und $sk$ für Secret oder Private-Key.
    \item Ein Tupel wird $(...)$ gekennzeichnet. Es zeigt die Menge an Informationen die in einer Nachricht zwischen zwei Akteuren enthalten ist.
    \item Verschlüsselung wird mit ${\{Nachricht\}}_{Schl\textit{ü}ssel}$ dargestellt. Dabei sind alle in den Klammern enthaltenen Informationen die Nachricht und der untere Teile der Schlüssel. Daher ist ${\{ID\}}_{pk}$ eine Verschlüsselung der $ID$ und ${\{ID\}}_{sk}$ eine Signatur der $ID$.
    \item Listen an Informationen sind mit $[Nachricht]$ markiert. Sie zeigen dass eine Tupel eine Reihe an $Nachrichten$ speichert. Wie viele Einträge zulässig sind, hängt von der genauen Situation ab.
    \item Ein Element zufällig aus einer Menge wählen, wird mit $element {\in}_{R} Menge$ dargestellt.
\end{itemize}

\section{Coin Generierungsphase}
\label{system:coingeneration}
Hier werden die Coins, die im späteren Verlauf beider Systeme verwendet werden, vom Datennutzenden erstellt und vom Datentreuhänder signiert. Die einzelnen Schritte sind in Abbildung \ref{fig:coin-generationphase} verdeutlich und werden im Folgenden beschrieben.
\subsection{Ablauf}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{CoinGenerationPhaseDiagramm.pdf}
    \caption{Coin Generierungsphase Ablauf}
    \label{fig:coin-generationphase}
\end{figure}

\paragraph{1. Zahlungseingang} $(apk \leftarrow AccountPublicKey, ES \leftarrow ErhalteneSumme)$\\
Der Exchange erhält über einen beliebigen Weg eine Summe und einen Konto Public-Key. Die genaue Umsetzung des Zahlungseingang liegt bei dem Exchange. Er kann alles zwischen einer Banküberweisung mit der $apk$ als Verwendungszweck bis hin zu einem Briefumschlag mit Bargeld und einem leserlich aufgeschriebenen $apk$ sein. Nach Eingang einer Zahlung erstellt der Exchange einen sogenannten $CoinGenerationToken$, bestehend aus $(nonce, apk, ES, spent \leftarrow false)$, verschlüsselt ihn mit dem $apk$ und speichert diesen intern. Der $CoinGenerationToken$ wird verschlüsselt, da sonst jede andere Person die den $apk$ mitgeschnitten hat selbst den Token verwenden kann, um Coins für sich zu generieren.

\paragraph{2. CoinGenerationToken abrufen} $(apk)$\\
Da der Exchange nur den $apk$ erhält hat er keine Möglichkeit den $CoinGenerationToken$ einem Datennutzenden zuzuweisen. Jetzt kann jeder beliebige Nutzer alle Einträge für einen $apk$ abfragen. Allerdings ist nur der Datennutzende in der Lage den $CoinGenerationToken$ zu entschlüsseln, der den passenden secret Key zum $apk$ hat. Dies ist im Idealfall nur der Datennutzende der die Transaktion getätigt hat.

\paragraph{3. CoinGenerationToken übertragen} $([\{(nonce, apk, ES)\}_{apk}])$\\
Auf eine $CoinGenerationToken$ Anfrage des Datennutzenden antwortet der Exchange mit allen noch nicht eingelösten Token für den $apk$. Nachdem der Datennutzende die Token erhalten hat kann er diesen zuerst mit dem passenden Private-Key entschlüsseln. Im Anschluss kann er selbst Coins erstellen. Ein Coin besteht aus $(nonce, value)$. Bei der Erstellung sind 2 Sachen zu beachten: Zuerst muss der summierte Wert aller erstellten Coins gleichgroß sein wie die $ES$ des Tokens. Des Weiteren gibt es eine Menge an möglichen Werten $MW$, sodass $\forall value\in MW$ gilt. Dies ist vor allem wichtig, da $value$ beim Signieren und Einlösen des Coins für den Exchange sichtbar ist und dieser bei einer Wahl eines selten vorkommenden $value$ eine Verbindung zwischen den Phasen herstellen kann.

\paragraph{4. Signierung Anfragen} $((nonce, apk, ES), [value])$
Eine Signieranfrage ist der Start eines Durchlaufs von partiell blinden Signaturen, bestehend aus einem $CoinGenerationToken$ und einer Menge an $values$. Zuerst kann der Exchange prüfen, ob der gesendete Token noch nicht eingelöst wurde. Anschließend summiert er alle $value$ auf und prüft, ob die Summe gleich dem $ES$ des Tokens ist. Wenn beide Überprüfungen akzeptieren, kann der Exchange mit dem partiell blind signieren anfangen und bei seinem gespeichert Token $spent \leftarrow true$ setzen um eine doppelte Einlösung zu verhindern.

\paragraph*{Gestrichelte Pfeile} $([a,b]), ([e])$\\
Die Pfeile zwischen 4. und 5. sind hier gestrichelt eingetragen, da sie notwendige Kommunikationsschritte von partiell blinden Signaturen abbilden. Sie sind essenziell für die Funktionsweise und wurden bereits in \ref{sec:partBlindSig} erklärt, weshalb sie hier nur zur Vollständigkeit aufgelistet werden.

\paragraph{5. Signieranfrage Antwort} $([r,c,s,d], \pi_{sk})$ \\
Vorausgesetzt alle Überprüfungen aus Schritt 4 akzeptieren, so erhält der Datennutzende nun eine Menge an partiell blinden signierten Coins und kann diese für spätere Verwendung lokal speichern. Zusätzlich berechnet der Exchange einen BDLEQ auf dem gleichen Weg, wie er in \ref{sec:privacy-pass} beschrieben ist. Nachdem der Datennutzende diesen verfiziert hat, kann er sicher sein, dass der Exchange zum signieren seiner Coins den selben Private-Key verwendet hat wie für die Signatur aller Coin Generierungsphasen. Sollten die Überprüfungen nicht akzeptieren so kann der Datennutzende entweder bei Schritt 4 mit anderen Coins oder bei Schritt 2 wieder ansetzen.\\

Auf diese Weise kann ein Datennutzender Geld bei einem Exchange einzahlen und eine dem Geldbetrag entsprechende Menge an Coins erhalten, ohne dass der Exchange die von ihm ausgehändigten Coins nachverfolgen kann. Gleichzeitig ist es für einen Datennutzenden nicht möglich Coins zu erhalten, für die er keinen monetären Gegenwert bereitgestellt hat.
\subsection{Finanzierung des Exchange}
Zusätzlich ist zu erwähnen, dass Exchanges finanziell motiviert sein können oder eine Gebühr verlangen möchten, um beispielsweise laufende Serverkosten zu decken. Sollte dies der Fall sein, kann vor dem Beginn der Coin Generationphase vom dem Exchange eine feste Gebühr ausgerufen werden. Wenn sich ein Datennutzender trotz der Gebühr dazu entscheidet diesen Exchange zu verwenden, so kann der Exchange nach dem Eingang einer Zahlung in Schritt 1 einen $CoinGenerationToken$ erstellen, welcher die Gebühr bereits abzieht. Wenn also ein Datennutzender eine Transaktion von $100$\texteuro bei Exchange mit $10\%$ Gebühr tätigt, so erstellt der Exchange einen $CoinGenerationToken$ für den angegebenen $apk$ mit $ES \leftarrow 90$\texteuro. Auf diese Weise kann eine Exchange seine finanziellen Interessen geltend machen. 

\section{Bezahlvorgang}
\label{system:payment}
Nachdem die Coins erstellt und signiert sind kann das Ausgeben dieser Coins behandelt werden. Dafür gibt es das Bezahlsystem,  welches den Datennutzenden erlaubt die Daten von Datengebenden anzufragen. Diese können der Anfrage nachkommen, wofür sie der Datennutzende im Gegenzug mit den Coins entlohnt. Damit bei dem Vorgang die Privatsphäre des Datengebenden so gut wie möglich geschützt wird, findet der Austausch der Daten und Coins über Postfächer beim Datentreuhänder statt. Dadurch entsteht keine direkte Kommunikation zwischen Datengebenden und Datennutzenden, die welche potenziell schützenswerte Informationen wie IP-Adresse oder dergleichen preisgibt. Wie der Ablauf genau funktioniert wird im Folgenden erklärt.

\subsection{Ablauf}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{PaymentDiagramm.pdf}
    \caption{Bezahlsystem Ablauf}
    \label{fig:payment}
\end{figure} 

In der Abbildung \ref{fig:payment} sind die Pfeile mit den Nummern 7,8 und 12 grau markiert. Dies hat den Grund, dass das Diagramm den gesammten Kommunikationsfluss zeigt und diese drei Schritt nur für das Bewertungssystem relevant sind, welches in Abschnitt \ref{system:reputation} beschrieben wird. Deswegen folgt die Auflistung und Erklärung der übertragenen Informationen erst in Abschnitt \ref{system:reputation}.

\paragraph{1. Aufruf starten} $(datatype, reputationThreshold, price)$\\
Der Datennutzende erstellt beim Datentreuhänder einen Aufruf zur Datenteilung. Damit verkündet er an alle Datengebenden, dass er Daten von einem bestimmten Typ sucht und benennt direkt, wieviel er für diese Daten bereits ist zu bezahlen. Da der Datennutzende nach Anlegen des Aufrufs direkt Daten erhalten kann, für die er Zahlen muss, braucht es eine Möglichkeit um ein gewisses Vertrauensminimum festzulegen. Der $reputationThreshold$ gibt dabei einen Schwellwert an, so dass der Aufruf nur für Datengebende mit einer Reputation über diesem Schwellwert sichtbar ist.


\paragraph{2. Aufrufliste anfragen} $(DG-ID, {\{DG-ID\}}_{DG-sk})$
Damit ein Datengebender über die Liste an allen aktuell laufenden Aufrufen bescheid weiß, muss er diese Liste beim Datentreuhänder anfragen. Dafür sendet der Datengebende seine $DG-ID$, um dem Datentreuhänder seine Identität zu nennen und die $DG-ID$ welche mit seinem Private-Key signiert ist. Damit kann der Datentreuhänder den Public-Key des Datengebenden aus einer Datenbank laden, da angenommen wird, dass jeder Datengebende sich bei der Registrierung auf einen Public-Key festlegt. Mit diesem Public-Key kann der Datentreuhänder die Signatur Überprüfen und dadurch sicher sein, dass der Datengebende tatsächlich der ist, der er vorgibt zu sein. Nun kann der Datentreuhänder die Reputation des Datengebenden abrufen und für die Zusammenstellung der Aufrufliste verwenden.

\paragraph{3. Aufrufliste Antwort} $([callDetails, DN-pk])$\\
Nachdem der Datengebende seine Identität bewiesen hat, kann der Datentreuhänder seine lokale Datenbank mit Aufrufen durchsuchen und alle Aufrufe, die einen Reputationsschwellwert niedriger als die Reputation der Datengebenden haben in eine Liste aufnehmen. Damit enthält jeder Eintrag der Liste aus dem Public-Key des Datennutzenden der den Aufruf gestartet hat und Aufrufdetails, die wichtige Informationen bezüglich des Aufrufs geben. Die genauen Inhalte der Aufrufdetails sind Treuhänderabhängig, da je nach Gebiet des Treuhänders verschiede Details über den Datennutzenden für die Entscheidung des Datengebenden wichtig sein können. In den meisten Fällen umfassen die Aufrufdetails Daten wie die angefragte Datentypkategorie (GPS-Daten, persönliche Daten, etc.), den Namen des Datennutzenden, den Preis den jeder Datengebende ausgezahlt bekommen soll, einen Titel oder eine Beschreibung. Auch Informationen darüber, ob es sich bei dem Datennutzenden um eine Forschungseinrichtung handelt, können hier kommuniziert werden.


\paragraph{4. Daten teilen} $(DN$-$pk, \{Shared-Key\}_{DN-pk}, \{referenceCode, dataLocation, dataKey\}_{Shared-Key})$\\
Der Datengebende hat die genannten Aufrufdetails erhalten und sich dazu entschieden, seine Daten für einen Aufruf mit einem Datennutzenden zu teilen. Generell gilt wie in \ref{sec:dt} erklärt, dass ein Datengebender seine Daten nicht selbst speichert, sondern sie verschlüsselt beim Datentreuhänder lagert. Er behält nur den Speicherort und Schlüssel der Daten, um jederzeit Zugriff auf diese zu haben. Um seine Daten mit einem Datennutzenden zu teilen, genügt es daher den Speicherort und Schlüssel zu übertragen.

Für die Übertragung des Speicherorts und Schlüssels wird ein Postfach beim Datentreuhänder verwendet. So kann ein direkter Austausch zwischen Datengebenden und Datennutzenden verhindert werden. Ein Datengebender kann Ort und Schlüssel verschlüsselt in das Postfach legen und nur der Datennutzende, der das Wissen über den passenden privaten Schlüssel besitzt, kann Ort und Schlüssel wieder entschlüsseln.

Einer der Betrugserkennungsmechanismen ist die Offenlegung der Kommunikation im Streitfall, so dass der Datentreuhänder die Nachrichten einsehen kann und entscheiden kann, welche der Parteien recht hat. Damit bei dieser Offenlegung nur genau die Nachrichten entschlüsselt werden, die Teil einer spezifischen Kommunikation zwischen Datengebenden und Datennutzenden sind, wird für jede Abwicklung eines Tausches ein neuer symmetrischer Schlüssel erstellt.\\

Damit ein Datengebender einen Eintrag in das Postfach zu Teilen von Daten senden kann, muss er zuerst die folgenden Informationen bestimmen. Zuerst wird der Public-Key des Datennutzenden im Klartext angegeben, da ein Datennutzender beim Abfragen des Postfaches so bestimmen kann, welche Einträge für ihn bestimmt sind. Anschließend wird ein neuer symmetrischer Schlüssel Shared-Key erstellt. Dieser wird mit dem Public-Key des Datennutzenden verschlüsselt, damit dieser den Shared-Key kennt. Nun kann der Datengebende den Shared-Key verwenden um das Tupel aus $dataLocation$, $dataKey$ und $referenceCode$ zu verschlüsseln. Hierbei sind $dataLocation$ und $dataKey$ die eben beschriebenen Speicherort und Schlüssel der Daten beim Datentreuhänder. Dabei sei angemerkt, dass sowohl $dataLocation$ als auch $dataKey$ mehr als nur eine Variable sein können und von dem vom Datentreuhänder verwendeten Speicherverfahren und Verschlüsselungsverfahren abhängen. Der $referenceCode$ ist eine zufällige Zahl die später bei Schritt 9 verwendet wird, um eine Zugehörigkeit von Übertragen der Daten und Coins herzustellen.

\paragraph{5. Datenpostfach abfragen} $(DN$-$pk)$\\
Der Datennutzende kann sich zu einem beliebigen Zeitpunkt dazu entscheiden, alle Nachrichten die den angegeben Public-Key enthalten anzufragen. Dafür muss er den gewünschten Public-Key mitübertragen, um den Datentreuhänder zu signalisieren, an welchen Nachrichten er interesse hat. Der Public-Key muss hier bei jeder Anfrage spezifiziert werden, da zum einen keine Form an Authentifizierung stattfindet und jeder alle Nachrichten eines Public-Keys anfragen kann. Zum anderen bleibt dem Datennutzenden so die Möglichkeit offen, für jeden Aufruf ein eigenes Schlüsselpaar zu verwenden. Dies kann beispielsweise große Vorteile bei der internen Organisierung haben.

\paragraph{6. Datenpostfach Antwort} $([\{Shared-Key\}_{DN-pk}, \{referenceCode, dataLocation, dataKey\}_{Shared-Key}])$\\
Nachdem der Datentreuhänder die Anfrage an das Datenpostfach erhalten hat, erstellt er eine Liste mit Postfacheinträgen, die den Public-Key der Anfrage im Klartext angegeben haben. Die einzelnen übertragenen Postfacheinträge können dabei auf den Public-Key verzichten, da dieser nur zu Identifizierung genutzt wird. Der Datennutzende kennt den Public-Key ohnehin da er ihn in der Anfrage definiert. Die vollständige Liste aller Postfacheinträge kann zurück an den Datennutzenden gesendet werden.

\paragraph{9. Daten anfragen} $(dataLocation)$\\
Der Datennutzende kann nun für jeden empfangenen Postfacheintrag den passenden Private-Key verwenden, um den Shared-Key des Eintrags zu entschlüsseln. Solange der Datengebende sich an das Protokoll gehalten und den Schlüssel, den er zum Verschlüsseln des Datentupels verwendet hat auch als Klartextschlüssel angegeben hat, funktioniert dieser Schritt einwandfrei und der Datennutzende erhält Zugang zu $dataLocation$, $dataKey$ und $referenceCode$. Jetzt kann er den Datentreuhänder nach den Daten an der angegebenen $dataLocation$ fragen, welche mit dem $dataKey$ verschlüsselt sind.

\paragraph{10. Daten Antwort} $(\{data\}_{dataKey})$\\
Die durch die $dataLocation$ beschriebenen Daten werden durch den Datentreuhänder ausgelesen. Da auch hier wieder keine Authentifizierung stattfindet, kann jeder einen beliebigen Datensatz beim Datentreuhänder anfragen und erhält die an der Stelle gespeichert Daten. Da allerdings nur der Datennutzende, der den $dataKey$ vorher erhalten hat die Daten lesen kann, ist das wahllose Anfragen von Daten beim Treuhänder sinnlos, da ohne Wissen über die $dataLocation$ nur Teile eines Datensatzes oder Überlappungen in andere Datensätze geschehen können, die verschiedene $dataKeys$ benötigen würden. Der Datentreuhänder kann daher mit den ausgelesenen Daten antworten ohne Schlüsse ziehen zu können, wer die Daten angefragt hat oder ob die Nachfrage Teil eines Tausches zwischen Datengebenden und Datennutzenden ist.

Nach Erhalt der verschlüsselten Daten kann der Datennutzende den zu den Daten gehörenden $dataKey$ verwenden, um die Daten zu entschlüsseln und an den Klartext zu gelangen. Jetzt kann der Datennutzende die Daten für seine Zwecke verwerten.

\paragraph{11. Coins in Postfach legen} $(referenceCode, \{[nonce,value]\}_{Shared-Key})$\\
\label{para:payment_9}
Mit der Verwertung abgeschlossen kann der Datennutzende nun den Datengebenden bezahlen. Dafür lädt er eine Liste an Coins aus seinem Speicher, die in der Summe gleich dem im Aufruf ausgeschrieben Preis sind. Er verwendet den in Schritt 6 erhaltenen Shared-Key um die Liste an Coins zu verschlüsseln. Anschließend verwendet er den ebenfalls in Schritt 6 erhaltenen $referenceCode$, um zusammen einen Eintrag an das Coinpostfach zu senden.

Da der $referenceCode$ von dem Datengebenden mit dem Shared-Key verschlüsselt wurde, ist davon auszugehen, dass ein Eintrag mit dem gleichen $referenceCode$ nur von dem Datennutzenden stammen kann, der den Aufruf gestartet hat und die Daten erhalten und verwertet hat.

\paragraph{13. Coinpostfach abfragen} $(referenceCode)$\\
Da ein Datengebender nach dem Erstellen eines Datenpostfacheintrags den dort genutzten $referenceCode$ lokal als offen abspeichert, kann er nun bei Bedarf den Datentreuhänder fragen, ob es bereits einen Eintrag in dem Coinpostfach mit diesem $referenceCode$ gibt. Er kann somit den Datentreuhänder fragen, ob er für das Teilen seiner Daten bereits bezahlt wurde.

\paragraph{14. Coinpostfach Antwort} $(\{[nonce,value]\}_{Shared-Key})$\\
Wenn der Datennutzende bereits einen Eintrag mit den verschlüsselten Coins eingesendet hat, so werden die unter dem $referenceCode$ angegebenen verschlüsselten Coins an den Datengebenden zurückgegeben. Der Datengebende kann daraufhin den Shared-Key, welcher in Kombination mit dem $referenceCode$ gespeichert wurde verwenden, um die erhaltenen Coins wieder zu entschlüsseln. Wenn er anschließend die Liste an Coins erhält, kann er überprüfen, ob die Summe der Coins auch den Preis des Aufrufs ergibt und die partiell blinde Signatur, die in der Coin Generierungsphase Schritt 4. und 5. ausgestellt wurde, auch tatsächlich valide ist. Sollten diese Tests beide akzeptieren, so kann der Datengebende die Coins lokal speichern, bis er sie einlösen möchte.

\paragraph{15. Coins einlösen} $([nonce,value], adresse)$
Ein Datengebender kann seine angesammelten Coins jederzeit einem Exchange senden. Dafür kann er die in Schritt 11 gespeicherten Coins aus dem Speicher lesen und gesammelt oder einzeln, mit einer Form der Zahlungsadresse an einen Exchange übertragen. Dabei ist die Form der $adresse$ vom Exchange abhängig. Bei der Implementation wird das Übertragen einer IBAN verwendet, allerdings ist es genauso gut möglich stattdessen eine Bitcoin Walletadresse oder eine beliebige andere Zahlungsmöglichkeit zu verwenden. Ein Exchange kann auch mehrere Zahlungsoptionen gleichzeitig anbieten. In dem Fall muss die Zahlungsoption als zusätzlicher Parameter mit übertragen werden.

\paragraph{16. Bestätigung} $([nonce, status \in \{true, false\}])$
Nachdem die Coins beim Exchange eingetroffen sind überprüft dieser, ob die Coins bereits vorher schon eingelöst wurden und ob die partiell blinde Signatur gültig ist. Anschließend meldet er dem Datengebenden den Status der Coins zurück. Dafür erstellt er eine Liste, die für jeden Coin den $nonce$ zur Zuteilung und einen boolean Wert zuordnet, der angibt, ob der jeweilige Coin akzeptiert wurde und sendet diese zurück.

\paragraph{17. Geld austeilen} $(address)$
Hier wird abschließend eine ausgehende Zahlung vom Exchange zu der angegebenen Zahlungsadresse getätigt. Die genau kommunizierten Daten sind hier von der Zahlungsoption abhängig. Allerdings muss hier sichergestellt werden, dass der ausgehende Betrag genau dem Wert der eingelösten Coins gleicht.

\subsection{Verwendung von Proxys und TLS}
Damit eine vollständige Anonymität erreicht werden kann, müssen sowohl Datengebende als Datennutzende ihre Nachrichten in den Schritten 4,7,12 und 13 über einen Proxy senden. Die Aufgabe des Proxys ist hier die Verschleierung der IP-Adresse. Durch das Weiterleiten durch einen Proxy bleibt die wahre IP-Adresse des Datengebenden bzw. Datennutzenden geheim. Ohne diesen Proxy kann der Datentreuhänder über die IP-Adresse mehrere Nachrichten miteinander verbinden und über längere Zeit mitschneiden, welcher Datengebende oder Datennutzende an wie vielen Handeln beteiligt war. Zugegebenermaßen ist eine dauerhaft gleichbleibende IP-Adresse eine Seltenheit. Der IPv4 Adressraum ist bereits seit mehreren Jahren erschöpft, weshalb IPv4 Adressen in regelmäßigen Abständen neu an aktuell sendende Geräte verteilt werden \todo{proof}. Trotzdem bleibt die IP-Adresse für mindestens eine Sitzung mit dem Datentreuhänder gleich, was diesem ermöglicht, alle in dieser Sitzung gesendeten Nachricht zu der selben Person zurückzuverfolgen. 

Die Art oder der Anbieter des Proxys ist in diesem Kontext nicht von Bedeutung. Solange er zuverlässig eingehende Nachrichten an die angegebene Ziel-IP-Adresse weiterleitet, bleibt die wahre IP-Adresse geschützt, was dem Datentreuhänder keine Möglichkeit zur Verlinkung mehrerer Nachrichten lässt.\\

Durch den Proxy wird die Identität des Sendenden versteckt, weshalb die Kommunikation nicht mit Hilfe von Signaturen vor dem Verändern geschützt werden kann. Dafür bräuchte der Empfänger der Public-Key des Sendenden. Um trotzdem die Sicherstellung von Integrität zu gewährleisten kann für die Schritte in denen ein Proxy verwendet, die Kommunikation über TLS ablaufen. Das Transport Layer Security Protokoll (kurz TLS) ermöglicht es einem Nutzer, mit einem Server zu kommunizieren und die dabei übertragenen Nachrichen gegen das Lesen und Veränderung durch Dritte zu schützen. Dafür benötigt TLS keinen Public-Key des Senders, sondern handelt bei jeder Verbindung einen neuen Schüssel aus \cite{Arfaoui2019The}. So kann weiterhin die Integrität aller Nachrichten eingehalten werden während der Server die Identität des Sendenden nicht verlinken kann.

\subsection{Bezahlungszeitraum}
\label{subsec:paymentTimespan}
Ein häufiger Betrugsversuch im Onlinehandel ist das Vortäuschen einer Zahlungsintention durch den Käufer, die nicht eingehalten wird. Hier trifft dies den Fall, in dem ein Datennutzender einen Aufruf startet, Datengebende in dem Vertrauen bezahlt zu werden ihre Daten weitergeben und der Datennutzende mit den gesammelten Daten verschwindet. Um Datengebende vor diesem Fall abzusichern, gibt es einen Maximalbezahlraum von 12 Stunden. Sollte also ein Datengebender innerhalb von 12 Stunden nach dem Weiterleiten seiner Daten keine Bezahlung erhalten, so hat er die Möglichkeit beim Datentreuhänder eine Beschwerde einzureichen. Wenn die Schuld tatsächlich beim Datennutzenden liegt und dieser keine Zahlung nachweisen kann, kann der Datentreuhänder den Datennutzenden nach wiederholtem Vorkommen dauerhaft von der weitergehenden Benutzung der Plattform ausschließen. Da zur Registrierung als Datennutzender in der Regel eine große Menge an Informationen wie Name, Branche, Verwendungszweck der Daten, etc. anzugeben sind, kann angenommen werden, dass sich ein Datennutzender nach dem Ausschluss nicht einfach unter einem anderen Namen wieder registeren kann. Außerdem wird in dem Paper \todo{proof einfügen} von K. Röbert, A. See, J. Schug und M. Fischer ein Verfahren präsentiert, dass es ermöglicht Nutzer - selbst nach Änderung ihres Namens - eindeutig wieder zu erkennen. Dieses Verfahren kann hier eingesetzt werden um sicherzustellen, dass kein Datennutzender der bereits von der Verwendung ausgeschlossen wurde, sich erneut registeren kann.\\
%\cite{roebert2024unlinkable}

Die Dauer von 12 Stunden kann von Treuhänder zu Treuhänder variieren. Dieser Zeitraum wurde gewählt, um einen bösartigen Datennutzenden keine zu große Menge an Daten stehlen zu lassen, bevor seine Machenschaften bemerkt werden. So steigt beispielsweise die Menge an Daten, die der Datennutzende stehlen kann, linear mit dem Bezahlungszeitraum, solange davon ausgegangen wird, dass der Andrang an Datengebenden, die ihre Daten teilen, zeitlich gleichverteilt ist. Gleichzeitig sollte der Zeitraum nicht zu klein gewählt sein, da eine Nichteinhaltung schwerwiegende Folgen hat. Bei einer Wahl von wenigen Sekunden reicht z.B. ein Serverausfall des Datennutzenden, um den Bezahlzeitraum zu überschreiten, ausreichend Beschwerden zu sammeln und einen Ausschluss auszulösen.



\subsection{Mögliche Streitfälle}
\label{subsec:payStreit}
Wie schon bei \ref{sec:mainPart_ziel} erwähnt wurde, sollen im Streitfall die Kommunikationsschritte, die den Austausch von Daten und die dazugehörige Bezahlung beinhalten, offengelegt werden können. Wie genau diese Offenlegung funktioniert und in welchen Fällen sie benutzt wird, wird hier geschildert.\\

\begin{enumerate}
    \item \textbf{Fehlerhafte Verschlüsselung.}\label{case:IncorrectEncryption}
    Der erste Streitfall kann nach Schritt 6 entstehen. Zu diesem Zeitpunkt hat der Datengebende bereits die $dataLocation$ und den $dataKey$ mit dem Shared-Key verschlüsselt, in das Postfach des Datentreuhänders gesandt und der Datennutzende hat diesen Eintrag erhalten. Sollte nun der Datennutzende den erhaltenen Eintrag nicht entschlüsseln können, so liegt dies entweder an einem inkorrekt angewendeten, angegebenem oder übertragenen Public-Key oder Shared-Key. Da der Eintrag anonym in das Postfach beim Datentreuhänder abgelegt wurde, besteht vorerst keine Möglichkeit für den Datennutzenden Maßnahmen zu ergreifen. Erst nach Ablauf der 12 Stunden, nach denen sich der Datengebende beschwert, dass er keine Coins erhalten hat, kann eine Lösung gefunden werden. Der Datengebende verweist auf den Eintrag, der mit Hilfe des Shared-Key verschlüsslt wurde und legt den Shared-Key offen. Der Datentreuhänder kann probieren den Eintrag mit Hilfe des Shared-Key zu entschlüsseln. Sollte es ihm nicht gelingen, liegt die Schuld beim Datengebenden. Wenn es ihm doch gelingt, so erhält der Datennutzende eine Chance zu zeigen, dass er den Shared-Key nicht lesen konnte. Dafür wird der Shared-Key mit dem im Eintrag gespeicherten Public-Key des Datennutzenden verschlüsselt. Sollte dabei ein unterschiedlicher Geheimtext entstehen als in dem Eintrag unter $\{Shared-Key\}_{DN-pk}$ abgelegt ist, so wurde falsch verschlüsselt. Stimmen die Geheimtexte überein, so ist anzunehmen, dass der Datennutzende sowohl den Schlüssel als auch die Daten lesen kann und die Bezahlung verweigert. 

    Für diese Beweisstruktur ist essenziell, dass die asymmetrische Verschlüsselung mittels ECC bei Verwendung der selben Parameter den selben Geheimtext ausgibt. Die ist nicht selbstverständlich, da für die Verschlüsselung häufig Techniken wie das Salten (hinzufügen einer Zufallsvariable) verwendet werden, um jedes Mal einen unterschiedlichen Geheimtext zu erhalten.
    
    
    \item \textbf{Fehlerhafte Datenparameter.}\label{case:IncorrectDataParameters}
    Dieser Fall tritt nach Schritt 8 ein. Der Datennutzende hat die unter $dataLocation$ abgelegt Daten erhalten, jedoch nach entschlüsseln dieser mit Hilfe des $dataKey$ nur unleserliche Geheimtexte erhalten. Auch hier wird der Shared-Key und der Postfacheintrag dem Datentreuhänder mitgeteilt. Dieser kann sich durch das Entschlüsseln Zugang zur $dataLocation$ und $dataKey$ verschaffen. Daraufhin überprüft er selbst, ob er die unter $dataLocation$ abgelegten Daten mit dem $dataKey$ entschlüsseln kann. Erhält er dabei ebenfalls nur unleserliche Geheimtexte, so ist die angegebene Kombination aus $dataLocation$ und $dataKey$ inkorrekt und die Schuld liegt beim Datengebenden. Sollte er jedoch leserliche Daten vorfinden, wird dies als Betrugsversuch des Datennutzende gewertet.

    \item \textbf{Nutzlose Daten.}\label{case:UselessData}
    Ähnlich wie Punkt \ref{case:IncorrectDataParameters} tritt dieser Streitfall nach Schritt 8 auf. Hier kann der Datennutzende die referenzierten Daten zwar lesen, empfindet diese jedoch als nutzlos. Das Vorgehen zur Offenlegung deckt sich ebenfalls mit dem von Punkt \ref{case:IncorrectDataParameters}. Der Datennutzende gibt Postfacheintrag und Shared-Key an, der Datengebende entschlüsselt den Eintrag, liest die Daten von der $dataLocation$ und entschlüsselt diese mit dem $dataKey$. Es gilt nun abzuwägen, ob die vorliegenden Daten tatsächlich nutzlos sind. Diese Bewertung ist in den meisten Fällen schwer zu entscheiden. Sollte es sich um einen völlig leeren Datensatz handeln, der nur aus Nullbits besteht, kann mit überwiegender Sicherheit angenommen werden, dass die Daten tatsächlich nutzlos sind. Andernfalls müsste der Datentreuhänder selbst die Mechanismen zur Auswertung der Daten besitzen. Wie in \ref{sec:dt} genannt wurde, besitzen eine Vielzahl an Datentreuhändern die Möglichkeit eine Qualitätssicherung der Daten zu durchzuführen. Dadurch kann ein Datentreuhänder die Qualität der Daten begründet einschätzen und entscheiden, ob der Datennutzende mit seiner Behauptung recht behält. Sollte der Datentreuhänder keine Qualitätssicherung liefern können oder sich bei der Beurteilung unsicher sein, wird im Zweifel für den Datengebenden entschieden.

    \item \textbf{Fehlerhafte Coins.}\label{case:IncorrectCoins}
    Ein Streitfall aufgrund fehlerhafter Coins kann sowohl in Schritt 11 als auch Schritt 13 eintreten. Im Fall von Schritt 11 hat der Datengebende gerade seine Bezahlung aus dem Coinpostfach des Datentreuhänders abgeholt. Daraufhin hat er die partiell blinde Signatur des Exchanges überprüft und festgestellt, dass die für den Coin angegebene Signatur nicht valide ist. Um den Datentreuhänder darüber aufzuklären, leitet er den Shared-Key, den $referenceCode$ des Postfacheintrags und den Public-Key des Aufrufs weiter und lässt den Datentreuhänder die Signatur prüfen. Wenn der Datentreuhänder anerkennt, dass die abgelegte Signatur ungültig ist, kann er den angegebenen Public-Key mit der Liste an Aufrufen abgleichen und den zu dem Aufruf gehörenden Datennutzenden bestrafen.
    
    Ein Coin kann genauso erst in Schritt 13 als fehlerhaft erkannt werden. Sollte die Signaturüberprüfung durch den Datengebenden in Schritt 11 ohne Probleme ablaufen, sendet er die Coins anschließend an den Exchange. Dieser wiederholt das Prüfen der Signatur. Da diese Validierung bereits in Schritt 11 reibungslose ablief, ist davon auszugehen, dass auch hier keine anderen Ergebnisse entstehen. Trotzdem kann ein Coin erst beim Einlösen an dem Exchange auf doppelte Ausgebung überprüft werden. Sollte der Exchange feststellen, dass ein übermittelter Coin zu einem vorherigen Zeitpunk schon einmal eingelöst wurde, so verweigert er die Annahme und meldet dies dem Datengebenden zurück. Daraufhin kann er genauso verfahren wie nach der Beschreibung für Schritt 11.

    \item \textbf{Überschreitung des Bezahlzeitraums.} \label{case:paymentExceeded}
    Wie schon in \ref{subsec:paymentTimespan} erläutert hat der Datengebende nach einer Wartezeit von 12 Stunden die Möglichkeit eine Beschwerde beim Datentreuhänder einzureichen. Dafür speichert er beim Absenden eines Eintrags zum Datenpostfach die Zeit und fragt in beliebigen Abständen das Coinpostfach nach dem $referenceCode$ ab. Sollte 12 Stunden nach absenden des Eintrags noch keine Antwort vorliegen, so leitet er den Shared-Key zusammen mit dem Datenpostfacheintrag an den Datentreuhänder. Dieser validiert, dass der Datengebende tatsächlich seine Daten geteilt hat und prüft selbst, ob bereits ein Eintrag unter dem $referenceCode$ des Eintrags eingesendet wurde. Trift dies nicht zu, wird das Handeln des Datennutzenden als Verstoß gegen die Einhaltung des Bezahlzeitraums gewertet und entsprechend bestraft.
\end{enumerate}


\section{Reputationsvergabe}
Nach Erhalt der Daten soll der Datennutzende in der Lage dazu sein, eine Bewertung für den Datengebenden aufgrund seiner Daten auszustellen. Erneut gilt es hier die Privatsphäre des Datengebenden weitgehend zu schützen. Dafür erhält der Datennutzende zusammen mit der $dataLocation$ und $dataKey$ einen Bewertungstoken, mit dem er eine Bewertung für die Qualität der Daten beim Datentreuhänder einreichen kann. Der Datentreuhänder kennt die Reputation jedes Datengebenden und ist für die Verwaltung, sowie regelmäßige Neuberechnung des Wertes zuständig.
In der Diskussion in \ref{sec:discussion} wird ein alternativer Ansatz besprochen. Er basiert auf einem Nachweis von bereits erhaltenen Coins durch den Datengebenden. Dort werden auch die Vor- und Nachteile dessen erklärt, sowie Gründe genannt weshalb das aktuelle Konzept preferiert wird.
\label{system:reputation}
\subsection{Ablauf}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{ReputationDiagramm.pdf}
    \caption{Reputationssystem Ablauf}
    \label{fig:reputation}
\end{figure}

Auch in Abbildung \ref{fig:reputation} werden wieder nur die für das Bewertungssystem relevanten Kommunikationsschritte hervor gehoben. Alle weiteren Schritte sind ausschließlich Teil des Bezahlsystems und in \ref{system:payment} dokumentiert.

\paragraph{4. Bewertungstoken mitsenden}$(RatingToken \leftarrow (nonce, {\{DG-ID\}}_{DT-pk},{\{nonce, {\{DG-ID\}}_{DT-pk}\}}_{DG-sk}))$\\
Beim Teilen von Daten kann ein Datengebender einen Bewertungstoken erstellen. Dafür generiert er zufällig einen $nonce$ der Sicherstellt, dass Bewertungen nicht doppelt eingereicht werden können. Anschließend verwendet er den Public-Key des Datentreuhänders, um damit seine Datengebende ID zu verschlüsseln. Dabei muss ein Saltwert hinzugefügt werden, da sonst beim jedem Verschlüsseln der ID der gleiche Geheimtext entsteht. Dadurch könnte ein Datennutzender den Ursprung von zwei Bewertungstoken verfolgen, was die Privatsphäre der Datengebenden verletzt. Abschließend berechnet der Datengebende eine Signatur über den zufälligen $nonce$ und die verschlüsselte $DG-ID$. Sie stellt sicher, dass ein Datennutzer nicht selbst $nonce$ generiert und mehrere Bewertungs für eine $DG-ID$ einreicht oder die $DG-ID$ nach erhalt des Token ändert. Mit diesen drei Werten ist der Bewertungstoken vollständig und wird zusammen mit der $dataLocation$ und dem $dataKey$ an das Datenpostfach vom Datentreuhänder gesendet. Der Bewertungstoken wird dafür Teil des Strings der mit dem Shared-Key verschlüsselt wird.

\paragraph{6. Bewertungstoken erhalten}$(RatingToken)$\\
Nach der Abfrage des Datenpostfachs in Schritt 5 erhält der Datennutzende die mit dem Shared-Key verschlüsselten Informationen über die Datenspeicherung beim Datentreuhänder, sowie den Bewertungstoken. Aufgrund der im Bewertungstoken übertragenen Details kann der Datennutzende kaum Überprüfungen auf dem Token durchführen. Er kann lediglich den verwendete $nonce$ auf Wiederholungen überprüfen um sicherzustellen, dass er nicht zwei Mal den gleichen Token erhalten hat. Die Signatur von $nonce$ und ${\{DG-ID\}}_{DT-pk}$ benötigt zwar zur Validierung nur den Public-Key des Datengebenden, aber da die $DG-ID$ verschlüsselt ist und im Postfacheintrag der Public-Key des Datengebenden nicht mitgesendet wird, kann der Datengebende den nötigen Public-Key nicht bestimmen. Daher bleibt ihm in diesem Moment nur die Möglichkeit dem Datengebenden und dem überwiesenen Bewertungstoken zu vertrauen und auf die Bewertung des Tokens durch den Datentreuhänder in Schritt 12 zu warten.

\paragraph{7. Reputation abfragen}$({\{DG-ID\}}_{DT-pk})$\\
Den soeben erhaltenen Bewertungstoken kann der Datennutzende verwenden um die darin gespeicherte verschlüsselte Datengebende ID an den Datentreuhänder zu senden. Er selber kann die ID nicht lesen. Da sie mit dem Public-Key des Datentreuhänders verschlüsselt ist, muss sie an ihn weitergeleitet werden um eine Aussage über die Reputation zu treffen. Dieser Schritt muss seperat von den Anfragen der Daten geschehen. Andernfalls weiß der Datentreuhänder, dass die gefragten Daten durch den gleichen Datengebenden hochgelanden wurde, dessen Reputation zurückgegeben werden soll.

Dieser Schritt ist nicht essentiell für das Protokoll und kann bei Bedarf auch weggelassen oder zu einem späteren Zeitpunkt ausgeführt werden. In dem Fall, dass ein Datennutzender keinen großen Wert auf die Korrektheit aller Reputationswerte legt und möglicherweise in seiner Rechenleistung etwas beschränkt ist, kann dieser Schritt und damit zusammen auch Schritt 8 übersprungen werden. Dadurch kann der Datennutzende zwei Kommunikationsschritte sparen. Ein Ansatz, in dem ein Datennutzender nur bei herausstechend schlechten Daten die Reputation des Datengebenden anfragt, ist beispielsweise genauso denkbar.

\paragraph{8. Reputation antwort}$(Reputation)$\\
Der Datentreuhänder kann die Datengebenden ID problemlos entschlüsseln. Anschließend kann er die Reputation des Datengebenden aus seiner Datenbank auslesen und den Wert an den Datennutzenden zurücksenden. Wie der genaue Wertebereich der Reputation definiert ist, hängt von der konkreten Implementation ab. Der empfohlene Bereich ist für eine Reputation $r$ ist $0\leq r\leq 1$. Sollte ein Datengebender das erste Mal abgefragt werden, so kann der Datentreuhänder - gegebenenfalls, dass die Datengebende ID tatsächlich existiert - einen neutralen Wert von hier $0,5$ zurück geben. Auf diesem Weg erfährt der Datennutzende die Reputation des Datengebenden, ohne herausfinden zu können, mit welchem Datengebenden er handelt.

\paragraph{12. Bewertung einreichen}$(RatingToken, rating, {\{DN-Certificate\}}_{DT-sk})$\\
Nachdem der Datennutzende eine Bezahlung in das Coinpostfach gesendet hat,hat er die Möglichkeit eine Bewertung für die Qualität der Daten abzugeben. Im Gegensatz zum Übertragen von Coins ist das Abgeben einer Bewertung nicht verpflichtend. Es kann genauso wie Schritt 7 bei durchschnittlicher Qualität der Daten ausgelassen werden um Performanz zu steigern. 

Um eine Bewertung einzureichen sendet der Datennutzende ein Tripel aus dem Bewertungstoken, der Zufriedenheit mit den Daten und einem Datennutzenden-Zertifikat. An dem Bewertungstoken hat sich nichts verändert. Er beinhaltet nach wie vor einen $nonce$, die verschlüsselte Datengebende ID und die Signatur über diese beiden Werte. Nun kann der Datennutzende einen Wert festlegen der seine Zufriedenheit mit den Daten repräsentiert. Dafür muss ein passender Wert aus dem gewählten Intervall bestimmt werden. Für das Datennutzenden-Zertifikat wird angenommen, dass es bei der Registrierung eines Datennutzenden beim Datentreuhänder ausgestellt wird. Es beinhaltet keine Informationen über den jeweiligen Datennutzenden sondern dient in dieser Situation ausschließlich dazu sicherzustellen, dass ein Datengebender sich nicht selbst bewerten kann. 

Das Zertifikat ist optimal durch alternative Beweisformen austauschbar die zeigen, dass es sich bei der bewertenden Person um einen Datennutzenden handelt, ohne dabei anzugeben welcher Datennutzende es ist. Denn wenn der Datentreuhänder bei einer Bewertung den Datennutzenden bestimmen kann, so hat er ein direktes Indiz für den Handel zwischen dem Datennutzenden und dem bewerteten Datengebenden.

Sobald das Tripel beim Datentreuhänder eintrifft überprüft dieser ebenfalls den $nonce$ auf wiederholtes Vorkommen und stellt mit Hilfe des Zertifikates sicher, dass es sich beim dem Bewerter um einen Datennutzenden handelt. Anschließend entschlüsselt er die $DG-ID$, ruft den bekannten Public-Key des entsprechenden Datengebenden ab und nutzt ihn, um die Signatur über den $nonce$ und die verschlüsselte $DG-ID$ zu validieren. Sollten alle diese Überprüfungen ohne Fehler ablaufen so kann der Datentreuhänder sicher sein, dass der Token tatsächlich durch den angegebenen Datengebenden erstellt wurde und ein Datennutzender ihn für die Bewertung von genau diesem Datengebenden benutzt. Er speichert die erhaltene Bewertung zusammen mit der $DG-ID$ lokal bis der Reputationswert des Datengebenden das nächste Mal neu bestimmt wird. Dies kann nach jeder Bewertung, in regelmäßigen Zeitabständen oder beim nächsten Anfragen von Aufrufen geschehen. Dafür kann der Datentreuhänder für jeden Datengebenden dessen aktuelle Reputation und sämtliche Bewertungen seit der letzten Berechnung verwenden, um damit eine neue Reputation zu erhalten. Wie die Gewichtung der unterschiedlichen Bewertungen verläuft ist hier wieder nicht genau vorgegeben. In Abschnitt \ref{chap:impl} wird ein mögliches Beispiel genannt.


\subsection{Weitere Streitfälle}
\label{subsec:repStreit}
Das Reputationssytem bietet weiteres Potenzial für Streitfälle, die durch die hier hinzukommenden Kommunikationsschritte entstehen können. Im folgenden sind diese Streitfälle aufgelistet.
\begin{enumerate}
    \item \textbf{Kein/Doppelter Bewertungstoken.} \label{case:badRepToken}
    Nachdem der Datennutzende in Schritt 6 den Datenpostfacheintrag entschlüsselt hat, prüft er den Bewertungstoken auf Existenz sowie Einzigartigkeit. Sollte dabei auffallen, dass entweder kein Bewertungstoken vorhanden ist oder dieser Token zuvor bereits erhalten wurde, so kann der Datennutzende dieses Verhalten melden. Er liefert dem Datentreuhänder den Shared-Key mit dem er den Datenpostfacheintrag entschlüsseln kann. Stellt der Datentreuhänder ebenfalls einen Fehler mit dem Bewertungstoken fest, so erlaubt er dem Datennutzenden, die Zahlung an den Datengebenden zu unterlassen. Wenn nach Ablauf von 12 Stunden der Datengebende den ``Zahlungszeitraum überschritten`` \ref{case:paymentExceeded} Streitfall meldet, so wird er darauf hingewiesen, dass er keine Zahlung erhalten wird.
    \item \textbf{Zu niedrige Reputation.} \label{case:insufficientRep}
    Wenn dem Datennutzenden nach entschlüsseln des Bewertungstokens und Anfragen der Reputation auffällt, dass der Datengebende nicht dazu berechtigt sein sollte auf den Aufruf zu antworten, legt er wieder den Shared-Key offen. Der Datentreuhänder kann die $DG-ID$ des Datenpostfacheintrags verwenden um zu überprüfen, ob der Datengebende in der Lage sein sollte den Aufruf zu sehen. Ist die Reputation des Datengebenden unter dem Reputationsschwellwert des in dem Datenpostfacheintrag referenzierten Aufrufs, so muss der Datengebende den Aufruf entweder von einer veralteten Aufrufliste haben oder ein anderer Datengebender mit ausreichender Reputation hat eine Liste von aktuellen Aufrufen öffentlich gemacht. Auch hier ist der Datennutzende nicht mehr dazu verpflichtet einen Eintrag in das Coinpostfach einzutragen, da der Datengebende unrechtmäßig einen Aufruf beantwortet hat.
    \item \textbf{Inkorrekte Signatur.} \label{case:badSignature}
    Im Anschluss an das Einreichen einer Bewertung in Schritt 12 wird die Signatur des Bewertungstokens durch den Datentreuhänder überprüft. Sollte dabei ein Fehler entstehen, so wird zuerst der Datennutzende beschuldigt die verschlüsselte $DG-ID$ ersetzt zu haben. Um diese Anschuldigung aufzuklären legt er den Shared-Key offen. Der Datentreuhänder entschlüsselt den Datenpostfacheintrag und prüft, ob die Signatur des übertragenen Token bereits fehlerhaft ist. Stellt sich der übertragene Token als intakt heraus, so hat der Datennutzende versucht die $DG-ID$ des Token zu verändern und so eine Bewertung für einen anderen Datengebenden auszustellen. Dafür kann ihn der Datentreuhänder temporär sperren. Ist der übertragene Token jedoch ebenfalls fehlerhaft, so ist ein Fehler bei der Erstellung der Signatur entstanden. Dieser kann sowohl unwissentlich - durch das falsche Signieren von korreken Werten - als auch wissentlich durch das absichtliche Verwenden einer anderen verschlüsselten $DG-ID$ auftreten. Aufgrund dessen kann der Datengebende hinter der $DG-ID$ nicht bestraft werden, da ein anderer Datengebender möglicherweise genau das bezwecken möchte. Daher bleibt wieder nur die Auslassung einer Bezahlung für den Datenpostfacheintrag.
\end{enumerate}

\subsection{Bewertungsfrequenz verschleiern}
Der Datentreuhänder kennt zwar die Reputation eines jeden Datengebenden, allerdings soll er dessen Handelspartner oder Frequenz nicht anhand der Bewertungen erschließen können. Leider ist dies sehr einfach, da der Datentreuhänder jede Bewertung einem Datengebenden zuordnen muss. Auch wenn nicht jeder Datennutzende eine Bewertung für jeden Handel mit einem Datengebenden ausstellt, lässt sich so für den Datentreuhänder trotzdem ein ungefähres Bild des Engagement eines Datengebenden bilden. Deswegen wird davon ausgegangen, dass es eine Instanz gibt, die sich als Datennutzender beim Datentreuhänder registriert, aber kein Interesse an Daten hat. Sie ist ausschließlich dazu da, um Verschleierungsbewertungen abzugeben. Dafür kann sie einen Aufruf starten wie ein regulärer Datennutzender. Die Datengebenden übertragen jedoch keine Daten an den Datennutzenden sondern lediglich einen Bewertungstoken. Dieser wird dazu verwendet eine Bewertung auszustellen, die mit der aktuellen Reputation übereinstimmt, sodass sich bei Neuberechnung der Reputation kein Unterschied ergibt. Dadurch kann ein Datengebender beliebig viele Bewertungen ausstellen, die seine Reputation nicht verändern und dadurch seine tatsächlich Handelsfrequenz gegenüber dem Datentreuhänder verschleiern. Nun kann der Datentreuhänder beim Erhalt einer Bewertung für einen Datengebenden nicht sicher sein, dass wirklich ein Handel stattgefunden hat, was die Privatsphäre des Datengebenden weiter stärkt.\\

Einige der in den Abschnitten \ref{subsec:payStreit}, \ref{subsec:repStreit} beschriebenen Streitfälle müssen für diesen speziellen Fall anders evaluiert werden. Beispielsweise ist hier der Datengebende im Unrecht wenn er 12 Stunden nach absenden des Tokens den Streitfall \ref{case:paymentExceeded} ausruft, da er keine Daten geteilt hat und somit auch keine Coins erhalten wird.

Bei der Bewertung dieser Streitfälle muss der Datentreuhänder wissen, ob es sich bei dem Datennutzenden um eine solche Verschleierungsinstanz handelt. Dies kompromitiert jedoch nicht die Verschleierung, da die Bewertungen über einen Proxy eingereicht werden und der Datentreuhänder beim Erhalt einer Bewertung nicht weiß, ob sie zur Verschleierung dient oder nicht. Er kann zwar anhand des Datenpostfachs erahnen, wie viele Verschleierungsbewertungen insgesamt abgegeben wurden. Solange die Datengebenden aber in ungleichen Menge Anfragen stellen, kann der Datentreuhänder auch hier durch die Verwendung von Proxys nicht bestimmen woher diese Anfragen stammen.


%==================================================================================================


\chapter{Implementation}
\label{chap:impl}
In dem hier folgenden Kapitel werden einige Details zu der Implementation geklärt, die im Kapitel \ref{chap:auswertung} ausgewertet wird. Dafür wird zuerst das TRESOR-Projekt kurz vorgestellt, einige Änderungen - die während der Implementation aufkamen - genannt und alle Parameter für die Wahl von Schlüssellängen und dergleichen begründet.

\section{TRESOR-Projekt}
Um aussagekräftige Testdaten der Entwürfe zu generieren, wurden die in Kapitel \ref{chap:systems} beschriebenen Systeme auf der bereits existierenden Codebasis des TRESOR-Projekts der Universität Hamburg implementiert. TRESOR ist ein C2B-Datentreuhandsystem das darauf abzielt, die in der dazugehörigen Data Vault mobile App eingegebenen oder generierten Daten vorzuverabreiten, zu verschlüsseln und auf Anfrage mit Datennutzenden zu teilen. Die App zielt besonders darauf ab, dem Nutzer volle Transparenz über die Verwendung seiner Daten zu geben. Es ist ein Pilotprojekt an dem eine Reihe an wissenschaftlicher Forschung in Feldern rund um Datentreuhandsysteme, Datenanonymisierung und privatsphärewahrender Datenspeicherung betrieben wird \cite{TRESOR}.

\section{Erweiterungen der Protokolle}
Damit die drei Entwürfe in den bestehenden Code eingebaut und benutzt werden können, mussten zwei Änderungen an den Schritten des Bezahlsystem vorgenommen werden. 
%Die erste Änderungen ist in Schritt 4. Dort überträgt der Datengebende den Speicherort und Schlüssel für das verarbeiten der Daten. Der in diesem Schritt neu erstellte Shared-Key wird zusätzlich mit dem Public-Key des Datennutzenden verschlüsselt, um nur ihm den Zugang zu gewähren. Allerdings kann die geforderte Integrität des ${\{Shared-Key\}}_{DN-pk}$ nur gewährleistet werden, solange der Datengebenden den verschlüsselten Geheimtext mit seinem Private-Key signiert. In dem Datenpostfacheintrag ist allerdings keinerlei Indiz auf die Identität des Datengebenden daher auch nicht auf seinen Public-Key der zum Validieren der Signatur nötig ist. Deswegen wird in der Implementation für jeden von Datengebenden erstellten Datenpostfacheintrag ein neues Schlüsselpaar generiert und mit dessen Private-Key der Geheimtext signiert. Damit der Datennutzende den nötigen Public-Key erhält, wird dieser im Klartext mit in dem Postfacheintrag übertragen. Dadurch wird einem Angreifer ermöglicht, beim Abfangen der Nachricht einen neuen Shared-Key zu generieren, diesen mit einem neuen Schlüsselpaar zu signieren und die Werte der Nachricht mit den neuen Werten für den Shared-Key, die Signatur und den Public-Key ersetzt. Nun kann der Datennutzende die $dataLocation$ und $dataKey$ nicht mehr entschlüsseln, da sich der Shared-Key geändert hat. Meldet er dieses Problem als Streitfall beim Datentreuhänder so überprüft dieser die Nachricht und sieht den Fehler auf der Seite des Datengebenden. 
%Hier ist allerdings zu beachten, dass dieser Angriff nicht erst durch das Hinzufügen der Signatur möglich wird. Wird der Shared-Key überhaupt nicht signiert, so kann ein Angreifer lediglich diesen Austauschen und gelangt zu der selben Auswirkung. ${\{oneTimeECKey\}}_{DG-sk},{\{{\{DG-ID\}}_{DT-pk}\}}_{DN-pk}$
\\

Die zweite Änderung befindet sich in Schritt 5. Hier wurde für eine effiziente Benutzung der Abfrage des Datenpostfachs ein Index hinzugefügt. Dieser hat den Sinn die Antwortgröße minimal zu halten. Wenn bei jeder Abfrage alle Einträge mit Public-Keys des Datennutzenden wiedergegeben werden, so enthält diese Liste nach einiger Zeit zum größten Teil Duplikate, die bereits behandelt wurden. Deswegen überträgt der Datentreuhänder bei jedem Postfacheintrag den Index mit. Dadurch kann ein Datennutzender in seiner nächsten Anfrage einen Index angeben, bis zu welchem er bereits alle Einträge kennt. Der Datentreuhänder kann anschließend nur die Einträge zurückgeben, die einen höheren Index besitzen als der spezifiziere. So bleibt diese in der Regel ähnlich groß anstatt mit der Zeit konstant zu wachsen.
\section{Parameterwahl}
An dieser Stelle wird die Wahl diverser Parameter der Implementation begründet. Die dafür behandelten Parameter beziehen sich hauptsächlich auf sicherheitskritische Parameter wie Schlüssellänge, Hashfunktionen und Noncelängen.\\
Generell gilt in der Literatur eine Security Bit Level von 128 Bits als ausreichende Sicherheit für die Jahre 2019-2030 und darüber hinaus \cite{elaine2016recommendation}. Selbstverständlich liefert ein höheres Security Bit Level eine höhere Sicherheit gegen Angreifer, die versuchen die Verschlüsselung zu brechen. Allerdings ziehen größere Schlüssellängen auch längere Berechnungszeiten der Ver- und Entschlüsselung mit sich. Es muss also abgewogen werden, ob eine ausreichende Sicherheit mit niedrigen Berechnungszeiten oder eine erhöhte Sicherheit mit erhöhten Rechendauer erreicht werden soll. In der hier vorliegenden Situation spielt eine hohe Sicherheit aufgrund des Handels mit Geld eine große Rolle. Da allerdings gleichzeitig die Anforderungen an Zeitsensitivität besteht, sollte die Rechendauer gering gehalten werden. Deswegen wird in der Implementation ein Security Bit Level von 128 Bit verwendet. Für die asymmetrische elliptische Kurve Krypographie entspricht dies einer Schlüssellänge von mindestens 256 Bits \cite{elaine2016recommendation,bsi2020cryptographic}. Um diesen zu generieren wurde die Kurve $secp256k1$ verwendet, die ein Security Bit Level von 128 Bit aufweist \cite{ecc-duka2020elliptic}. Der symmetrische MAES-Algorithmus ist durch seine Implementation an eine Schlüssellänge von 128 Bits gebunden, was ebenfalls dem Security Bit Level von 128 Bits entspricht \cite{elaine2016recommendation}.\\



Die Sicherheit von Hashfunktionen und deren Kollisionsresistenz kann genauso mit einem Security Bit Level bewertet werden. Sie werden in der Erstellung von Signaturen sowie Hash-based Message Authentication Code (kurz HMAC) - welche die Integrität bei asymmetrisch verschlüsselten Nachrichten gewährleisten - verwendet. Die Sicherheit einer Hashfunktion hängt dabei von der Anwendung ab. Beispielsweise hat der SHA-256-Algorithmus für Signaturen Security Bit Level von 128 Bit, während der gleiche Algorithmus für das Erstellen von HMAC ein 256 Bit Security Level erreicht \cite{elaine2016recommendation}. Trotzdessen wird SHA-256 in der Implementation für sowohl das Erstellen von Signaturen als auch von HMAC verwendet.\\

Für die Wahl des CoinGenerationToken Nonce, Coin Nonce und Bewertungstoken Nonce ist ausschlaggebend, dass sich während der Laufzeit des Systems beim kontinuierlich neu Generieren von Werten keine Doppelungen entstehen. Deswegen werden für diese Werte Zufallszahlen mit ebenfalls 128 Bits gewählt, was die Wahrscheinlichkeit eines doppelt vorkommenden Wertes auf $\frac{n}{2^{128}}$ setzt. Dabei ist $n$ die Anzahl an bereits erstellten Nonces für den jeweiligen Verwendungszweck. Eine Wiederholung des gleichen Werts zwei unterschiedlichen Nonces, wie beispielsweise bei einem CoinGenerationToken und einem Coin, hat dabei keine Auswirkungen.

\section{Reputationsberechnung}
Die Reputation eines Datengebenden muss regelmäßig neu berechnet werden. Die Berechnung nach jedem Eingang einer neuen Bewertung zu starten ist jedoch unnötig aufwendig. Deswegen wird in der Implementation die Reputation eines Datengebenden bei dessen Nachfrage nach der Aufrufliste gestartet. Dies geht möglichen Verwirrung aus dem Weg die entstehen, falls ein Datengebender an der Schwelle eines Aufrufs ist, diesen Beantwortet und er, bevor der Datennutzende die Reputation überprüft, eine schlechte Bewertung erhält, die ihn unter die Reputationsschwelle treibt.

\begin{figure}[h]
    \centering
    \label{fig:reputationWeights}
    \includegraphics[width=0.8\linewidth]{ReputationWeights.png}
    \caption{Verteilung der Gewichte auf den Index}
\end{figure}

Für die Neuberechnung werden (soweit vorhanden) die letzen 50 Bewertungen des Datengebenden nach Eingangszeitpunkt absteigend sortiert, sodass die neueste Bewertung an erster Stelle steht. Anschließend werden die Bewertungen mit einem Faktor multipliziert der sich aus der Funktion $f(index)=(0,1\cdot index + 1)^{-0,7}$ ergibt. Der Graph der Funktion ist in Abbildung \ref{fig:reputationWeights} visualisiert. Danach werden alle vervielfachen Bewertungen aufsummiert und durch die Summe der Faktoren geteilt. Die Funktion bevorzugt die neuesten Bewertungen und verleiht ihnen größeren Einfluss auf den entgültigen Reputationswert. Dadurch kann sich ein Nutzer, der in der Vergangenheit viele gute Bewertungen erhalten hat nicht in Sicherheit wiegen sondern wird dazu angereizt, konstant weiter gute Bewertungen zu erhalten.

%schritt 4 braucht auch pk des dg -> für jeden neues keypair erstellen
%schritt 5 hinzufügen von index für benutzbarkeit

%Parameter wahl für alle krypographie wert (schlüssellänge, tokennonce länge, etc)

%Wie wird reputation neu berechnet / wann


%==================================================================================================

\chapter{Evalutation}
\label{chap:auswertung}
Nun da die Formalisierung des Konzepts abgeschlossen ist, kann mit der Auswertung begonnen werden. Dafür wird das Konzept hauptsächlich bezüglich der Sicherheit und des Rechenaufwands analysiert. Für die Analyse der Sicherheit werden die Angreifermodelle aus Kapitel \ref{chap:req} aufgegriffen, weiter spezifiert und anhand von ihnen gezeigt, welche Schwachstellen das Konzept gegen die verschiedenen Angreifer aufweist. Zur Analyse des Rechenaufwands werden gemessene Laufzeiten der Implementation begründet und miteinander verglichen. Später wird zusätzlich geprüft ob die in Kapitel \ref{chap:req} gesetzten Anforderungen erfüllt, sowie antworten auf die in Kapitel \ref{chap:intro} genannten Foschungsfragen besprochen. Zum Schluss gibt es ein Diskussion mit bestehenden Problemen und weiterführenden Ansätzen.
\section{Bewertung der Sicherheit}
Die Sicherheit eines Systems in Bezug auf verschiedene Angriffe ist ein essenzieller Faktor für den Erfolg dieses Systems. Insbesondere bei kryptographischen Protokollen, wie Keyexchange Protokollen oder dem in Kapitel \ref{chap:systems} präsentierten Bezahlsystem, ist die Sicherheit einer der entscheidenen Punkte die den Erfolg bestimmen können. Um einen Standard für eine Bewertung der Sicherheit einzuführen, definierten D. Dolev und A. Yao im Jahr 1983 das erste Angreifermodell \cite{am-dolev1983security}. Ein Angreifermodell beschreibt einen theoretischen Angreifer, der probiert, dem zu untersuchenden System Schaden zuzufügen oder Informationenen zu extrahieren. Dafür müssen die Rahmenbedingungen des Angreifermodells genau bestimmt werden. Es umfasst in der Regel Angreiferziele, Angreiferannahmen und Angreiferfähigkeiten \cite{am-do2019role}. 
\begin{itemize}
    \item \textbf{Angreiferziele.} Für einen Angreifer gibt es mehrere Ziele, die er mit seinem Angriffen erreichen möchte. Er kann beispielsweise Interesse daran haben, die übertragenen Informationen mitzuschneiden, Geheimnisse wie private oder Sitzungsschlüssel herauszufinden oder die Kommunikation vollständig zu verhindern. 
    \item \textbf{Angreiferannahmen.} Sie beschreiben das Umfeld und die Ressourcen des Angreifers. Häufig auftretende Annahmen sind die Unterscheidung zwischen externem oder internem Zugriff auf ein Netzwerk, die Beschränkung auf einen polynomial probabilistischen Angreifer, was beschreibt dass der Angreifer nur $O(n^k)$ Rechenaufwand bei einem Konstanten $k$ und Eingabelänge $n$ hat und bei der Berechnung zufällige Werte raten darf.
    \item \textbf{Angreiferfähigkeiten.} Die Fähigkeiten eines Angreifers sind durch seine Handlungsmöglichkeiten definiert. So kann ein aktiver Angreifer die Fähigkeiten besitzen, Botnetzwerke zu verwenden um DDoS Attacken zu starten, per Brute Force probieren ein Passwort zu knacken oder Analysen des Geheimtexts durchzuführen, die Schlüsse auf die übertragene Nachricht zulassen. Passive Angreifer hingegen haben meist nur die Möglichkeit, die Kommunikation zu beobachten und Schlüsse aus dem Netzwerkverkehr abzuleiten.
\end{itemize} 
Zusammen ergibt die Definition des Angreifermodells eine maximale Stärke die ein Angreifer besitzen und trotzdessen das System nicht brechen kann. Sollte er in nur wenigen Punkten mehr Macht besitzen als das Angreifermodell vorgibt, so ist die Sicherheit des Systems nicht mehr gewährleistet und der Angreifer kann sein definiertes Ziel erreichen. Daher spricht die Aufstellung eines starken Angreifermodells und die Verteidigung gegen dieses für die Robustheit des Systems. Eine genaue Definition des Angreifermodells ist wichtig, da unpräzise Formulierung ein mehrdeutiges Angreifermodell liefern, das nicht genau bestimmen kann, wogegen das System geschützt ist.

\subsection{Angreifermodelle der Coin Generierungsphase}
Bei einer Durchführung des Coin Generierungsprotokolls treten Exchange und Datennutzende als Akteure auf. Für jeden von ihnen muss ein Angreifermodell definiert werden um die Sicherheit bei korrumpierten Kommunikationteilnehmern zu zeigen. Zusätzlich soll die Sicheheit gegen einen außenstehenden Angreifer gezeigt werden.

\paragraph{Bösartiger Datennutzender}
Ein bösartiges Verhalten eines Datennutzenden kann durch eine Übernahme eines Datennutzenden durch einen externen Angreifer oder durch bösartige Interessen des Datennutzenden selbst entstehen. In beiden Fällen ist das Ziel des Angreifenden, entweder Coins mit größerem monetären Wert zu erhalten als der ursprüngliche Zahlungseingang beim Exchange zulässt oder eine Möglichkeit zu erhalten, selbst Coins zu signieren. Die dafür zu treffenden Annahmen sind, dass es sich um einen aktiven Angreifer handelt. Er verfügt über unbegrenzten Speicher und kann Algorithmen mit polynomieller probabilistischer Rechenzeit ausführen. Zusätzlich kennt er den Public-Key des Exchanges und den für den Zahlungseingang verwendeten $AccountPublicKey (apk)$. Mögliche Angriffe die er starten kann sind Replay-Attacken, welche eine zuvor gesendete Nachricht wiederholen, sowie Chosen-Plaintext-Attack, bei denen der Angreifer den Nachrichteninhalt bestimmt und observieren kann wie sich der Geheimtext verhält, sowie Brute-Force-Attacken zum Erraten des Private-Keys und Geheimtextanalysen zur Herausarbeitung des Private-Keys.\\

Da der Ablauf des Zahlungseingangs in Schritt 1 hauptsächlich von der konkret verwendeten Methode abhängt, kann hier davon ausgegangen werden, dass der Angreifer eine reguläre Transaktion leistet, da er ohne den damit entstehenden $CoinGenerationToken$ das Protokoll nicht vorführen kann. 
Anschließend erfragt er beim Exchange alle Token mit dem verwendeten $apk$. Nach Erhalt des soeben erstellten Token, kann er probieren Coins zu generieren, die den $ES$ Wert des Token übersteigen und den $value$ zusammen mit dem Token zum Exchange zu senden. Da der Exchange zuerst den summierten $value$ Betrag aller Coins mit dem $ES$ des Tokens vergleicht, wird der Exchange bereits hier feststellen, dass ein Angreifer probiert, mehr Geld zu erhalten als er bezahlt hat. Der Versuch schlägt hier fehl.\\

Der Angreifer ist daher gezwungen eine zum $ES$ passende Menge an $values$ zu generieren und zu übertragen. Der Exchange antwortet mit einer Liste von $a,b$ für jeden $value$. Nun kann der Angreifer sich entscheiden das Protokoll für partiell Blinde Signaturen (Abschnitt \ref{sec:partBlindSig}) zu verlassen und anstatt die vorgesehen Berechnung für $e$ auszuführen, $e$ als Variable für den Chose-Plaintext-Angriff zu verwenden. Er schreibt jedem $e$ einen leicht veränderten Wert zu, sendet diesen an den Exchange, erhält für jedes $e$ ein Tupel aus $(r,c,s,d)$ und kann probieren, die Unterschiede zwischen den verschiedenen $r$ mit Hilfe der Geheimtextanalyse herauszuarbeiten. \todo{Faktorisierungsproblem mit großen Primzahlen referenzieren} Da der Exchange zur Berechnung von $r$ zwei dem Angreifer unbekannte Variablen benutzt ($u,x$) und auf das Ergebnis $mod$ $q$ anwendet, ist bei einer ausreichend großen Wahl von $u,x,q$ anzunehmen, dass das Ergebnis pseudozufällig erscheint und keine Hinweise auf $x$ liefert. Dabei verliert der Angreifer zusätzlich bei jedem Versuch den Wert des Coins, da die entstehende Signatur nicht gültig ist.\\

Sollte der Angreifer $e$, wie vom Protokoll vorgesehen, berechnen und nach Erhalt von $(r,c,s,d)$ probieren $u,x$ zu erraten, sodass die Ergebnisse seiner Berechnung mit $(r,c,s,d)$ übereinstimmen, kann er diesen Brute-Force-Angriff ohne Kosten (abgesehen von Rechenaufwand) starten. Solange $q$ groß genug gewählt ist (in der Implementierung 128bits) mit $u{\in}_{R} {\mathbb{Z}}_{q}$ ist die Chance allein $u$ korrekt zu bestimmen bereits $\frac{1}{2^{128}} \approx \frac{1}{3,4\cdot10^{38}}$ ausreichend gering, um das Gelingen des Erratens von $u$ und $x$ als vernachlässigbar anzunehmen.

Der Angreifer kann auch probieren, anhand des Public-Keys des Exchange einen Faktorisierungsalgorithmus laufen zu lassen, um den Private-Key zu bestimmen. Noch sind aber keine Algorithmen bekannt, die das Faktorisierungsproblem in aufbringbarer Zeit effizient lösen können, weshalb der Angreifer auch mit diesem Vorgehen nicht an den Private-Key kommt.\todo{proof}\\

Nach Ausstellung der Signatur ist der Wert jedes Coins fest zugeteilt. Wenn ein Angreifer versucht den $value$ des signierten Coins zu ändern, werden damit die Grundlagen zum Überprüfen der Signatur umdefiniert, was dazu führt, dass jede Validierung fehlschlägt. Somit verliert der Coin schlagartig seinen Wert sobald der Angreifer den $value$ verändert.\\

Letztlich kann der Angreifer probieren einen Replay-Angriff zu starten und einen bereits einmal eingesetzten $CoinGenerationToken$ erneut mit einer Reihen an $values$ zum Exchange zu senden. Jedoch ist in Kapitel \ref{system:coingeneration} definiert, dass der Exchange jeden erhaltenen $CoinGenerationToken$ auf eine doppelte Einlösung überprüft. Daher wird der Exchange die Annahme des Tokens verweigern und der Angreifer schafft es auch hier nicht, mehr Coins zu erhalten als ihm zustehen.\\

\paragraph{Neugieriger Exchange.}
Der Exchange stellt in der Coin Generierungsphase eine Rolle mit großer Verantwortung da. Er hat die Aufgabe Geldsummen sicher zu verwalten und trotz der Anonymität des Konzeptes genau die passenden Mengen ein- und auszuzahlen. Trotzdem wird das Angreifermodell für den Exchange hier nur schwach definiert. Dies hat vor allem den Hintergrund, dass das Konzept eines Exchanges zum Tausch von Geld in die jeweilige Kryptowährung bereits etabliert ist und viele Sicherheitsmaßnahmen bestehen, die den Exchange zu einem gutmütigen Verhalten zwingen \cite{gnu-burdges2016enabling,kim2018risk,baum2021p2dex}. Deswegen wird im Folgenden nur die Sicherheit des Protokolls gezeigt aber nicht die Sicherheit des Exchanges.
Angenommen der Exchange kann nicht durch Unbefugte übernommen werden, so sind seine Angreiferziele in Erfahrung zu bringen, welcher Datennutzende wie viele Coins besitzt und wie viel diese Wert sind. Zusätzlich ist er daran interessiert herauszufinden, mit wem der Datennutzende der sich die Coins signieren lässt, handelt. Dafür möchte er sowohl die Identität des Datennutzenden als auch des Coins wiedererkennen können und verschiedene Signiervorgänge untereinander verlinken können. Die Angreiferannahmen beschränken sich zum größten Teil auf passives Verhalten. Er hält sich überwiegend an das Protokoll und beobachtet die Kommunikation mit dem Datennutzenden, um daraus Informationen zu sammeln. Seine Rechenleistung ist polynomial probabilistisch und er kennt sämtliche Informationen die im ersten Schritt angegeben werden. Die Angreiferfähigkeiten sind ebenso eingeschränkt. In den meisten Fällen antwortet er auf Anfragen des Datennutzenden wie das Protokoll es vorgibt. Nur die Wahl der Berechnungswerte für die partiell blinden Signatur kann er variieren.\\

Wie bereits definiert hält sich der Exchange zunächst an das Protokoll. Er erstellt beim Eintrefen einer Zahlung einen $CoinGenerationToken$ mit dem $ES$ und $apk$ gleich den Werten der Zahlung und legt diesen mit dem $apk$ verschlüsselt in seinem Speicher ab. Da der $apk$ ein regulärer Public-Key ist, kann der Exchange keine fundierten Kenntnissen aus einem $apk$ ziehen. Erst sobald der selbe $apk$ für eine spätere Zahlung erneut angegeben wird, kann davon ausgegangen werden, dass der Zahlungseingang von der gleichen Person stammt. Wenn ein Datennutzender aber für jede Zahlung einen neuen $apk$ generiert, kann der Exchange zwei verschiede Zahlungen nicht zu der gleichen Person zurückführen.

Auf Anfrage gibt er den $CoinGenerationToken$ heraus. Bei dem Berechnen der partiell blinden Signatur ist der einzige Wert, für den eine Abweichung vom Protokoll sinnvoll sein kann, der Private-Key. Die Werte $u,s,d,z,c,r$ sind bei jedem signierten Coin unterschiedlich. Diese gleich zu behalten würde ab dem zweiten Coin dem Datennutzenden auffallen. Der Private-Key hingegen ist dem Datennutzenden nicht bekannt und die Auswirkung beim auswechseln des Private-Keys sind nicht feststellbar. Daher kann der Exchange probieren, für jeden signierten Coin einen eigenen Private-Key zu verwenden. Dadurch kann er beim späteren Erhalt von Coins im Bezahlsystem durch den Datengebenden nachvollziehen, aus welcher Signieranfrage der Coin stammt und kann so die Beziehung zwischen dem Datennutzenden und Datengebenden vermuten. An dieser Stelle greift jedoch der $BDLEQ$, welcher in \ref{sec:privacy-pass} erklärt wurde und verhindert, dass der Exchange ungehindert den Private-Key austauschen kann. Bei einem Versuch den Private-Key zu ersetzen, zeigt der $BDLEQ$, dass der verwendete Private-Key nicht mehr mit dem beworbenen übereinstimmt. Somit ist der Exchange gezwungen den gleichen Private-Key einzusetzen, was die potenzielle Wiedererkennung im späteren Verlauf verhindert.\\




Angreiferziele:
    - will wissen welcher DN wie viele coins hat und die viel geld
    - will verschiedene signiervorgänge verlinken können
Angreiferannahmen:
    - passive beobachtend
    - poly rechenaufwand
    - kennt werte des coingentoken
    - hält sich ans protokoll außer immer gleichen sk
Angreiferfähigkeiten:
    -

erhält zahlung -> stellt token aus (apk kann selbst bei gleichen DN jedes mal anders sein) -> kein Informationsgewinn aus apk
antwortet mit token -> erhält values -> benutzt für jede anfrage unterschiedliches keypair -> bdleq stimmt nicht mehr -> DN beschwert sich und meldet exchange -> wird gebannt
muss also gleich schlüssel benutzen -> kennt nur value aber nicht nonce -> wenn token eingelost wird ist nonce unbekannt und value stammt aus kleiner menge an werten -> also auch viel zu häufig vorkommend um schlüsse zu ziehen
Kann die Identität auf keiner weise nachverfolgen

\textbf{Außenstehender}
%-> Kommunikation über Internet daher trotzdem unterscheidung zwischen außer und innentäter nicht nötig
Angreiferziele:
    - will selbst coins erhalten
    - will DN vom erhalten seiner coins abhalten
Angreiferannahmen:
    - kennt DN-ID des DN
    - kenn den apk und kann jeden apk zu dn-id matchen
    - unbegrentz speichplatz und polynomialzeit Rechenleistung
    - ist aktiv
Angreiferfähigkeiten:
    - chosen-plaintext
    - brute force
    - cryptoanalysis

Kann bei schritt 2 sich als dn ausgeben und nach token für apk fragen.
Erhält verschlüsselten token -> polynomialzeit reicht nicht, cryptoanalysis liefert keine herausstechenden ergebnisse
kann probieren token zu erraten -> $100.000 * 2^256$ -> $1/1,15*10^82 $-> vernachlässigbar
kann nichts weiter tuhen da partblindsig über gleiche tcp sein muss und token zum start nötig ist
wiederholtes ausprobieren von token kann maximal dos verursachen


\subsection{Angreifermodelle der Bezahlphase}
Für die Definition der Angreifermodelle wird zunächst angenommen, dass jeder Akteur der an dem System beteiligt ist, mehr oder weniger aktiv an der Ausnutzung möglicher Schwachstellen interessiert ist. Somit ergeben sich für die 4 verschiedenen Akteure 4 Angreifermodelle mit unterschiedlichen Eigenschaften.
\begin{itemize}
    \item \textbf{Bösartige Datennutzende}
    %define adversary goals, assumptions, capablities
    \item \textbf{Bösartige Datengebende}
    \item \textbf{Ehrlich aber neugieriger Datentreuhänder}
    \item \textbf{Ehrlich aber neugieriger Exchange}
\end{itemize}
%Sicherheit gegen Angreifer Modelle:
%    - honest but curios DT
%    - honest but curios Exchange
%    - bösartige DN
%    - bösartige DG



\section{Analyse des Rechenaufwands}
In diesem Abschnitt wird der implementierte Entwurf auf seine Laufzeit und Rechenaufwand untersucht. Dafür wird zuerst die Messumgebung beschrieben und anschließend Prognosen über die vorraussichtliche Laufzeit erstellt, die mit den tatsächlich Messwerten verglichen werden. Danach wird die Performanzauswirkung von unterschiedlichen Technologien gemessen, wie beispielsweise ECC vs RSA.

\subsection{Messumgebung}
\label{subsec:timeMessureComputer}
Die Erhebung der Messdaten erfolgt jeweils auf zwei unterschiedlichen Geräten. Datensatz 1 stammt von einem Computer mit einem AMD Ryzen 5800X mit 3,80 GHz Basisgeschwindigkeit und 8 Kernen. Dieser Computer verfügt über 40 GB Arbeitsspeicher und verwendet Windows Version 22H2. Der Datensatz 2 wurde auf einem Computer, der einen Intel i9-10850K mit 3,60 GHz Basisgeschwindigkeit und 10 Kernen eingebaut hat, generiert. Zusätzlich verfügt der zweite Computer über 64 GB Arbeitsspeicher und läuft auf macOS Sonoma 14.7.

Alle hier gesammelten Ergebnisse stammen von Simulationen, die ausschließlich auf einem Computer durchlaufen wurden. Sämtliche Kommunikationen liefen über localhost und nicht wie bei einer produktiven Umgebung über mehrere Netzwerke. Aufgrund dessen beinhalten die gemessenen Zeiten keine Übertragungsverzögerungen die durch das Senden der Daten über längere Distanzen entstehen können.

%Anzahl an interaktionen miteinbeziehen
%Erwarteter Aufwand schätzen

\subsection{Laufzeit einer vollständigen Ausführung}
Hier werden die Laufzeiten von vollständigen Ausführungen des Protokolls betrachtet. Sie umfassen ebenfalls die Zeiten von einzelnen Phasen, sodass diese untereinander verglichen werden können.\\

Zum aktuellen Zeitpunkt umfasst die Implementation lediglich einen Datengebenden, sowie einen Datennutzenden. Allerdings ist die Aufteilung in mehrere Datengebende und Datennutzende hier überflüssig da - wie oben erwähnt - alle Rechenoperationen auf einem Computer stattfanden. Daher wird erwartet, dass die Zeitmessungen sich nach einer Aufteilung nicht stark verändern und erst bei einer Aufteilung auf verschiedene Computer bemerkenswerte Unterschiede entstehen.\\

Es gibt 4 Parameter die zur Bewertung des Laufzeitverhalt in Betracht gezogen werden. Der erste Parameter ist die Anzahl an $CoinGenerationToken$ die vom Exchange bearbeitet wird. Der zweite ist die Anzahl an Coins pro $CoinGenerationToken$. Der dritte ist die Anzahl an Datenpostfacheinträgen die durch den Datennutzende behandelt werden müssen und der vierte Parameter ist die Anzahl an Coins die ein Datennutzender für jeden Datenpostfacheintrag verwendet. Um die Auswirkung der unterschiedlichen Parameter zu differenzieren, wurden 4 Datensätze erhoben. In ihnen erhöht sich der jeweilige Parameter von 1 bis 150 in Zehnerschritten. Leider kann aufgrund der Funktionweise der dritte und vierte Parameter nicht seperat erhöht werden. Eine getrennte Zunahme des dritte Parameters führt dazu, dass mehr Datenpostfacheinträge gesendet werden, die alle mit einem Coin bezahlt werden. Bleiben allerdings Parametere eins und zwei unverändert so wird zu Beginn nur ein Coin erstellt, obwohl in späteren Verlauf 150 Coins benötigt werden.\\

In Abbildung \ref{fig:win_coins} sind zwei Messwertfolgen zu sehen. Sie beziehen sich auf die Erhöhung der ersten beiden Parameter. Dabei stellt die blaue Linie die Laufzeit der Coin Generierungsphase dar, in der eins stetig wachsende Menge an $CoinGenerationToken$ erstellt wird. Dabei wird für jeden dieser $CoinGenerationToken$ genau ein Coin generiert, was am rechten Bildrand zu einer Erstellung von 150 Coins führt. Die orange Linie hingegen verwendet konstant genau einen $CoinGenerationToken$ und erhöht dessen Wert. So können bei wachsender X-Achse in jedem Schritt mehr Coins für den einen Token erstellt werden, was auch hier wieder zu einer abschließenden Menge von 150 Coins führt. Die Abbildung \ref{fig:mac_coins} zeigt den selben Sachverhalt mit Messungen auf dem in Abschnitt \ref{subsec:timeMessureComputer} beschriebenen MacOS System.
\begin{figure}[h]
    \caption{Unterschied zwischen steigenden CoinGenerationToken und steigenden Coins innerhalb eines CoinGenerationToken auf Windows}
    \label{fig:win_coins}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_win_coins.png}
\end{figure}
\begin{figure}[h]
    \caption{Unterschied zwischen steigenden CoinGenerationToken und steigenden Coins innerhalb eines CoinGenerationToken auf MacOS}
    \label{fig:mac_coins}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_mac_coins.png}
\end{figure}
Unter direktem Vergleich der Abbildungen \ref{fig:win_coins} und \ref{fig:mac_coins} fällt auf, dass das Erstellen von einem $CoinGenerationToken$ mit 150 Coins erheblich schneller abläuft, als das Erstellen von 150 \\$CoinGenerationToken$ mit jeweils einem Coin. Dies hängt vorallem mit dem anfallenden Mehraufwand in der Verschlüsselung und Datenübertragung zusammen. In Kapitel \ref{system:coingeneration} wird beschrieben, dass für das Erstellen von Coins in der Coin Generierungsphase - mit Einbezug der partiell blinden Signaturen - 6 Kommunikationsschritte zwischen dem Exchange und dem Datennutzenden stattfinden. Daraus ergibt sich, dass für das Erstellen und Signieren von 150 Coins innerhalb eines $CoinGenerationTokens$, einen Verbindungsaufbau und 6 Datenübertragungen umfasst, welche jeweils alle mit ECC verschlüsselt sind. Im anderen Fall von 150 $CoinGenerationToken$ entspricht der Aufwand 150 Verbindungsaufbauten sowie 900\todo{Nachrichtenkomplexität verwenden} Datenübertragungen, die mit ECC verschlüsselt sind. Die Nachrichteninhalte die Verschlüsselt werden sind hier dafür nur $\frac{1}{150}$ Mal so groß. Der deutliche Unterschied zwischen den beiden Linien stellt eindeutig dar, welche der beiden Methoden performanter ist.

Deswegen wurde in Abbildungen \ref{fig:win_3} und \ref{fig:win_4} zusätzlich die Anzahl an Coins pro $CoinGenerationToken$ erhöht, da die Auswirkung auf die Gesamtlaufzeit so geringer ist.\\

Beachtlich sind hier vorallem die unterschiedlichen Laufzeiten zwischen der Ausführung auf Windows mit einem AMD Prozessor und der Ausführung auf MacOS mit einem Intel Prozessor. Bei der Ausführung mit 150 $CoinGenerationTokens$ unterscheiden sich die Messwerte beinahe um 50\%. Auf Windows wird dafür eine Gesamtrechendauer von 13696 Millisekunden benötigt, während es auf MacOS lediglich 9277 Millisekunden sind. Gleichzeitig ist das Erstellen von 150 Coins innerhalb eines $CoinGenerationTokens$ auf Windows schneller. Dort wird eine Zeit von 1958 Millisekunden erreicht, während MacOS für die gleichen Opertationen 2389 Millisekunden in anspruch nimmt. Leider kann aufgrund des Aufbaus der beiden Computer nicht bestimmt werden, ob dieser Performanzunterschied durch das Betriebssystem oder durch den Prozessorhersteller entsteht.\\

Die folgende Abbildung \ref{fig:win_3} zeigt das Verhalten der Laufzeiten bei den schrittweisen Anstieg an Datenpostfacheinträgen. Zusätzlich wurden die Anzahl an Coins pro $CoinGenerationToken$ erhöht um ausreichend Coins bereitszustellen. In der Abbildung sind 5 Linien zu sehen. Sie beziehen sich auf unterschiedliche Abschnitte im Protokoll. Die blaue Linie ist die gerade bereits betrachtete Dauer der Coin Generierungsphase. Die orange Linie bildet die Protokollschritte 2,3,4 des in Kapitel \ref{system:payment} dargelegten Bezahlsystem ab. Die Schritte 5,6,7,8,9,10,11 und 12 sind in der grünen Linie mitinbegriffen. Die rote Linie stellt die abschließenden Schritte 13,14,15 und 16 dar.
\begin{figure}[H]
    \caption{Steigende Anzahl an Datenpostfacheinträgen und Coins bei einem CoinGenerationToken und einem Coin pro Bezahlung}
    \label{fig:win_3}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_win_3.png}
\end{figure}
Hier ist zu sehen, dass das Teilen von 150 unterschiedlichen $dataLocations$ und $dataKeys$ in knapp unter 6 Sekunden geschieht. Verglichen mit der Zeit der Bewertung und Bezahlung ist die Zeit passend, da das Anfragen der Aufrufliste ein Mal geschehen muss und nur der Protokollschritt 4 150 Mal ausgeführt. Dieser Schritt verschlüsselt die $dataLocation$, den $dataKey$, den $BewertungsToken$ und den $referenceCode$ symmetrisch mit MAES, was in der Regel schnellere Berechnungszeit liefert als ECC. Nur der Shared-Key wird mit Hilfe von ECC verschlüsselt. 

Bei der Bezahlung und Bewertung hingegen fallen mehrere Schritt an. Hier wird für jeden Datenpostfacheintrag das erhaltene Tupel entschlüsselt, die Reputation angefragt, die Daten angefragt, der Coin zu Bezahlung mit dem $referenceCode$ zurück an das Bezahlpostfach gesendet und der Bewertungstoken zusammen mit einer Bewertung eingereicht. Daher ist ein Anstieg von 5900 Millisekunden auf 18457 Millisekunden beachtlich, da sich die Gesamtanzahl an Operation um ein Fünffaches erhöht. 

Über die Gesamtdauer gesehen wird der erste Computer auch hier wieder um ca 50\% von dem zweiten Computer geschlagen. Dessen Zeiten sind in Abbildung \ref{fig:mac_3} visualisiert und liegen bei 20934 Millisekunden im Gegensatz zu 32447 Millisekunden des ersten Computers. 

\todo{wieder?}Auch hier ist wieder zu beobachten, dass sich alle Zeitmessungen linear zum Anstieg des Parameters verhalten und keine polynomiellen Zeitanstiege zu erkennen sind, welche die Anforderung der Skalierbarkeit verletzten würden.


\begin{figure}[H]
    \caption{Steigende Anzahl an Coins pro Bezahlung und Coins pro CoinGenerationToken bei einem Datenpostfacheintrag und CoinGenerationToken}
    \label{fig:win_4}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_win_4.png}
\end{figure}
In Abbildung \ref{fig:win_4} wurde nun der vierte Parameter erhöht und so ein Datenpostfacheintrag mit einer steigenden Anzahl an Coins bezahlt. Die Zuteilung der Farben zu den Protokollschritten bleibt hier unverändert zur letzten Abbildung. Es wird sofort deutlich, dass auch hier das Übertragen mehrerer Coins in einer Nachricht erheblich performanter ist, da sich die Gesamtdauer von in Abbildung \ref{fig:win_3} 32447 Millisekunden zu 5227 Millisekunden in Abbildung \ref{fig:win_4} senkt. Diese Abnahme ist wieder durch das Einsparen von hunderten Opertation begründet. Die Protokollschritte 5-12 werden nur noch ein Mal ausgeführt anstatt jeweils 150 Mal. Dadurch sinkt die Zahl an Interaktionen zwischen dem Datentreuhänder und dem Datennutzenden von 1200 auf 8. Im Gegenzug ist die in Schritt 11 verschlüsselte Nachricht, die sämtliche Coins zur Bezahlung beinhaltet, erheblich länger wie bei der Bezahlung mit einem Coin.

Die Dauer für das Einlösen der erhaltenen Coins wird durch die verringerte Anzahl an Postfacheinträgen ebenso gesenkt. Während sie in Abbildung \ref{fig:win_3} noch bei 6198 Millisekunden lag, ist sie in Abbildung \ref{fig:win_4} bereits auf 2557 Millisekunden gefallen. Dies ist hauptsächlich auf den gesparrten Rechenaufwand durch das Entschlüsseln einer einzelnen Nachricht zurückzuführen. Die Zeit zum Erstellen und Absenden eines Datenpostfacheintrags bleibt hier konstant bei ca. 100 Millisekunden, da in jedem Durchlauf genau ein Eintrag erstellt wird und dieser nicht von der Anzahl an Coins beeinflusst wird.


\subsection{Laufzeit ohne Reputation}
Wie in Kapitel \ref{system:reputation} erwähnt wurde, kann das Anfragen der Reputation des Datengebenden sowie das Ausstellen einer Bewertung für die erhaltenen Daten übersprungen werden. Sollte ein Datennutzender keinen großen Wert auf die Qualität der Daten geben oder möchte anderen Datennutzenden keine Einschätzung über die Qualität liefern, so kann er den jeweiligen Schritt weglassen um Rechenaufwand zu sparen. Die Abbildung \ref{fig:win_noRep} zeigt dabei, wie sich das Weglassen der einzelnen Schritte auf die Gesamtlaufzeit auswirkt.
Die unterschiedlich eingefärbten Teile der Balken in der Abbildung \ref{fig:win_noRep} stellen die Laufzeiten der jeweiligen Programmabschnitte dar. Ganz Links ist für die Vergleichbarkeit die Zeit einer Ausführung mit Kontrollparametern zu sehen. Sie umfasst 10 $CoinGenerationToken$ mit jeweils 30 Coins, 100 Datenpostfacheinträge und 3 Coins pro Bezahlung. Diese Werte werden ebenfalls in den kommenden Abschnitten \ref{subsec:runTimeRSA} und \ref{subsec:runTime256Bit} verwendet um eine Kontrollzeit zu definieren. Der Balken in der Mitte verwendet dieselben Werte und zeigt die Dauer der Ausführung, in der das Anfragen der Reputation übersprungen wird. Eine Bewertung wird hier weiterehin abgegeben. Beim rechten Balken wird auch das Einreichen einer Bewertung übersprungen und nur eine Bezahlung abgegeben.\\

\begin{figure}[h]
    \caption{Laufzeitverhalten beim überspringen der Reputationsanfrage und Bewertung}
    \label{fig:win_noRep}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_win_noRep.png}
\end{figure}
In der Abbildung \ref{fig:win_noRep} ist zu erkennen, dass ein moderater Unterschied in der Ausführungsdauer entsteht, sollten die eben angesprochenen Teile des Reputationssystems übersprungen werden. Sämtliche Zeiten der anderen Balkenteile unterscheiden sich nur in Messungenauigkeiten. Durch das Entfallen der Reputationsanfrage werden bereits zwei Protokollschritte übersprungen, was auf die Menge an Ausführungen hochgerechnet, 200 Nachrichten entspricht. Der dadurch gewonnene Zeitunterschied umfasst 2956 Millisekunden. Beim zusätzlichen weglassen der Bewertung werden weitere 100 Nachrichten gesparrt. Da diese Nachrichten den Bewertungstoken enthalten muss der Datentreuhänder beim Empfang die - in Kapitel \ref{system:reputation} genannte - Überprüfung vornehmen. Diese Überprüfungen bleiben beim Weglassen einer Bewertung aus, was die Laufzeit um weitere 3334 Millisekunden verkürzt. Für Datennutzende mit wenig Rechenleistung ist es daher eine Überlegung wert, von dem vorgesehenen Protokoll etwas abzuweichen und die Anfrage der Reputation beispielsweise nur bei schlechten Daten durchzuführen, um zu prüfen, ob es sich um einen Betrugsversuch handelt.
\subsection{Laufzeit mit 256 Bit Security Level}
\label{subsec:runTime256Bit}
In dem Kapitel \ref{chap:impl} wurde beschrieben, dass sich für die Einhaltung eines 128 Bit Security Level entschieden wurde und die Gründe dafür genannt. Der größte Nachteil ist der Anstieg der Rechenzeit, den größere Schlüssellängen mit sich ziehen. Um genau zu bewerten wie groß der dadurch entstehende Unterschied ist, wird in der Abbildung \ref{fig:win_256bit} ein Durchlauf mit Kontrollausführungszeit - wie oben beschrieben - gegen einen Durchlauf mit einem 256 Bit Security Level verglichen.
Das Security Bit Level von 256 Bits kann leider nicht ganz erreicht werden. In Abschnitt \ref{sec:aes} wird der MAES Algorithmus erklärt. Dieser ist aufgrund seines Konzeptes an einen 128 Bit langen Schlüssel gebunden und kann daher nicht auf 256 Bit erweitert werden. Ansonsten wurde für ECC die $secp521r1$ Kurven verwendet, die 256 Bit Sicherheit liefert \cite{ecc-duka2020elliptic}, sowie die Parameter für die partiell blinden Signaturen auf - für 256 Bit Security übliche - Werte angehoben. Diese entsprechen $L=15360$ und $N=512$ \cite{elaine2016recommendation}.

Die Abbildung \ref{fig:win_256bit} zeigt die gemessenen Zeitunterschiede bei der Verwendung von 256 Bit Security Parametern. Nicht in der Abbildung aufgeführt sind die benötigten Zeiten zum Erstellen der Schlüssel, da diese beim Starten der Applikation generiert werden und daher nicht in die Berechnungszeit von Aktionen einfließen. Diese werden zu Beginn einmal erstellt. Jedoch sind sie nicht zu vernachlässigen. Bei ECC ist der Unterschied beim Generieren eines Schlüssels vergleichsweise gering. Die Kurven $secp256k1$ und $secp521r1$ unterscheiden sich hierbei um circa 10 Millisekunden \cite{ecc-duka2020elliptic}. Das Generieren von Parametern der partiell blinden Signaturen hingegen unterscheidet sich in der eigenen Implementation signierfikant. Für den Vergleich wurde die Zeit der Generierung für 128 Bit und 256 Bit jeweils 10 Mal gestoppt. Die Werte für 128 Bit lagen zwischen 95 - 6737 Millisekunden mit einem Durchschnitt von 1760 Millisekunden. Bei 256 Bit hingegen lagen die Werte zwischen 6556-102644 Millisekunden mit einen Durchschnitt von 38022 Millisekunden. Hier ist der Unterschied zwischen den Security Level deutlich erkennbar.

\begin{figure}[h]
    \caption{Laufzeitverhalten unter Einsetzung eines 256 Bit Security Levels}
    \label{fig:win_256bit}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_win_256Bit.png}
\end{figure}
Die Zeitunterschiede die durch das Verschlüsseln sowie Signieren von Nachrichten entstehen sind in Abbilung \ref{fig:win_256bit} dargestellt. Für die Werterhebung wurde jeweils ein Durchlauf mit den Kontrollparametern für 128 Bit auf der linken Seiten und 256 Bit auf der rechten Seite ausgeführt. Hier sind die unterschiedlichen Laufzeiten gut zu erkennen. Die Gesamtausführungszeit steigt um beinahe die Hälfte, von 23713 Millisekunden auf 34372 Millisekunden. Da alle Schritte der Protokolle die Daten verschlüsselt übertragen, sind Anstiege in alle Bereichen zu verzeichnen. Am größten sind die Unterschiede in der Coin Generierungsphase. Hier wächst die gemessene Zeit um mehr als das Doppelte, von 1591 Millisekunden auf 3624 Millisekunden. Dies hängt mit der Anwendung der partiell blinden Signatur zusammen, welche durch den jetzt fünffach so langen Schlüssel, vergleichsweise mehr Zeit in Anspruch nimmt, als das Verschlüsseln mit einem doppelt so langen Schlüssel bei ECC. Das Erstellen und Hochladen der 30 Datenpostfacheinträge verzögert sich um 2079 Millisekunden und liegt unter Verwendung von 256 Bit bei insgesamt 5977 Millisekunden. Die Steigerung liegt hier - genauso wie bei der Zeit zum Bezahlen und Bewerten - bei knapp 50\%. Die Zeit zum Bezahlen steigt von 12999 Millisekunden auf 18036 Millisekunden. Erstaunlicherweise verlängert sich die Zeit zum Einlösen der Coins am geringsten. Der gemessene Anstieg beträgt hier lediglich 1509 Millisekunden, was in etwa 30\% entspricht. Anhand der Coin Generationphase wurde erwartet, dass sich die Zeit zum Einlösen ähnlich stark verlängern wird. Allerdings scheint dieser Abschnitt des Protokolls durch die Auswirkungen der verlängerten Schlüssel am wenigsten betroffen zu sein.

\subsection{Laufzeit mit RSA}
\label{subsec:runTimeRSA}
In Abschnitt \ref{sec:ecc} wird erklärt, dass die elliptische Kurven Kryptographie große Unterschiede in der Laufzeit im Vergleich zu RSA erzielen kann. Für eine Bewertung des Zeitaufwands der durch die Verwendung von ECC gewonnen wird, wurden sämtliche ECC Kommunikationsverschlüsselungen durch RSA ersetzt und die Zeit einer Ausführung gemessen. Für die RSA Schlüssel wurde ein Länge von 3072 Bit verwendet, wie sie in der Literatur für ein Security Bit Level von 128 Bit empfohlen wird \cite{elaine2016recommendation}. Die daraus entstandenen Ergebnisse sind in Abbilung \ref{fig:win_rsa} zu sehen. Sie zeigen die Ausführung mit den Kontrollparametern, unter Verwendung von ECC auf der linken Seite und Verwendung von RSA in der Mitte sowie auf der rechten Seiten. Auf der rechten Seite wird für jeden Postfacheintrag ein neues Schlüsselpaar erstellt, wie es im Protokoll (Kapitel \ref{system:payment} Schritt 4)\todo{is it though?} vergeben ist. Dieser Schritt wurde in der Mitte ausgelassen, um die reinen Unterschiede der Verschlüsselungsdauer zu beurteilen.

\begin{figure}[h]
    \caption{Laufzeitverhalten unter Verwendung von RSA für Verschlüsselung}
    \label{fig:win_rsa}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_win_RSA.png}
\end{figure}
Die hier entstehenden Unterschiede sind maßgeblich und deutlich erkennbar. ECC schlägt RSA - ohne neue Schlüsselgenerierung - bei der Gesamtlaufzeit um den Faktor fünf. Dabei werden vorallem die Zeiten der Coin Generierungsphase sowie Coin Einlösephase langsamer als die anderen Protokollschritte. Sie steigen um die Faktoren $7,3$ und $7,1$, während sich die Zeiten für das Hochladen der Datenpostfacheinträge und das Bezahlen und Bewerten um die Faktoren $3,7$ und $5,4$ erhöht. Bei Vergleich der Laufzeit mit neuer Schlüsselgenerierung werden die in Abschnitt \ref{subsec:runTime256Bit} genannten Unterschiede der Laufzeiten zwischen ECC und RSA deutlich. Die Differenz zwischen den Zeiten des Datenpostfacheintrags Erstellen, zwischen dem mittleren und rechten Balken, berufen sich auf 340.000 Millisekunden, was in etwa 3400 Millisekunden für das Erstellen eines Schlüsselpaars bedeutet.

Anhand der Abbildung \ref{fig:win_rsa} ist eindeutig zu sehen, dass die Verwendung von ECC als Verschlüsselungsmethode immense Laufzeitunterschiede liefert. Zusammen mit der neuen Schlüsselgenerierung für jeden Postfacheintrag ergibt sich für ECC eine Laufzeit, die $21,16$ Mal schneller ist wie die gleichen Opertationen mit RSA. Daher wird die Verwendung von ECC hier eindeutig vor RSA bevorzugt.\\

Abschließend kann zusammengefasst werden, dass sich die Rechendauer der vier verschiedenen Protokollabschnitte mit einer steigenden Anzahl an Eingaben linear verhält. Zwar laufen einige Abschnitte schneller als andere, wie beispielsweise das Erstellen von Coins durch einen $CoinGenerationToken$ anstatt durch mehrere, was sich selbst von Computer zu Computer unterschiedlich verhalten kann. Allerdings wird zu keinem Zeitpunkt ein polynomielles Laufzeitverhalten beobachtet. Das Überspringen von Reputationsanfragen wie das Prüfen der Reputation oder das Einreichen einer Bewertung, ist in bestimmten Situationen möglich und liefert dabei Laufzeiteinsparungen von bis zu über 6 Sekunden. Daher können Strategien entwickelt werden um die Verwendung dieser Anfragen zu minimieren und so den Rechenaufwand zu verringern. Insbesondere für Datennutzende, die nur über eingeschränkte Rechenleistung verfügen, sind solche Möglichkeit in Betracht zu ziehen. Ein Security Bit Level von 128 Bit ist laut Literatur auch für die kommenden Jahre mehr als ausreichend \cite{elaine2016recommendation,bsi2020cryptographic}. Während der Umstieg auf ein Security Bit Level von 256 Bits in anbetracht der sensiblen kommunizierten Daten nachvollziehbar wäre, zieht dieser einen zusätzlichen Rechenaufwand mit sich. Die dadurch hinzukommende Steigerung von fast 50\% ist nicht zuvernachlässigen. Aufgrund dessen wird für die Verwendung des Systems ein Security Bit Level von 128 Bit empfohlen. Anhand der in Abbildung \ref{fig:win_rsa} visualisierten Performanzunterschiede zwischen ECC und RSA wird hier eindeutig ECC für die Verschlüsselung und Schlüsselgenerierung empfohlen, da es RSA um mehr als ein Zwanzigfaches überholt.

\section{Erfüllen der Anforderungen}

\section{Wie kann ein privatsphäreschützender Anreiz zur Benutzung eines Datentreuhändermodells geschaffen werden?}
\section{Wie kann dieser Anreiz gegen Missbrauch geschützt werden?}

\section{Diskussion}
\label{sec:discussion}
% schutz gegen veröffentlichung von calls sodass jeder zugang hat ist überflüssig -> streitfall
%länge des ciphertext lässt schließen wie viele coins übertragen werden
%  Lösen des Streitfalls legt viele Daten offen, braucht meist Menschen der bewertet
%DN Zertifikat durch ZKP ersetzen

%==================================================================================================


\chapter{Zusammenfassung}


%==================================================================================================



\thispagestyle{empty}

\vspace*{\fill}
\pagestyle{empty}

{
    \normalsize
    \begin{center}
        \textbf{Eidesstattliche Erklärung}
    \end{center}
    Hiermit versichere ich an Eides statt, dass ich die vorliegende Arbeit im Bachelorstudiengang Software-System-Entwicklung
    selbstständig verfasst und keine anderen als die angegebenen Hilfsmittel –- insbesondere keine im Quellenverzeichnis nicht benannten Internet-Quellen –- benutzt habe. Alle Stellen, die wörtlich oder sinngemäß aus Veröffentlichungen entnommen wurden, sind als solche kenntlich gemacht. Ich versichere weiterhin, dass ich die Arbeit vorher nicht in einem anderen Prüfungsverfahren eingereicht habe.
    \vspace*{1cm}\\
    Hamburg, den \today
    \hspace*{\fill}\begin{tabular}{@{}l@{}}\hline
    \makebox[5cm]{Knut Hoffmeister}
    \end{tabular}
    \vspace*{3cm}
}
\vspace*{\fill}

\printbibliography

\appendix 

\chapter{Laufzeit Abbildungen}

\begin{figure}[H]
    \caption{Mac 1}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_mac_1.png}
    \label{fig:mac_1}
\end{figure}
\begin{figure}[H]
    \caption{Mac 2}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_mac_2.png}
    \label{fig:mac_2}
\end{figure}
\begin{figure}[H]
    \caption{Mac 3}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_mac_3.png}
    \label{fig:mac_3}
\end{figure}
\begin{figure}[H]
    \caption{Mac 4}
    \centering
    \includegraphics[width=0.8\textwidth]{figure_mac_4.png}
    \label{fig:mac_4}
\end{figure}

\chapter{Tabelle der Laufzeiten}
My laufzeiten
\end{document}